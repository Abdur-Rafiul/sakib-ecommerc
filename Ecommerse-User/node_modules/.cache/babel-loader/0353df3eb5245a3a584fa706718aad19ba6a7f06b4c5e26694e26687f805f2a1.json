{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Curl = void 0;\nconst tslib_1 = require(\"tslib\");\n/**\r\n * Copyright (c) Jonathan Cardoso Machado. All Rights Reserved.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n */\nconst events_1 = require(\"events\");\nconst string_decoder_1 = require(\"string_decoder\");\nconst assert_1 = tslib_1.__importDefault(require(\"assert\"));\nconst stream_1 = require(\"stream\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = require('../package.json');\nconst Easy_1 = require(\"./Easy\");\nconst Multi_1 = require(\"./Multi\");\nconst mergeChunks_1 = require(\"./mergeChunks\");\nconst parseHeaders_1 = require(\"./parseHeaders\");\nconst CurlCode_1 = require(\"./enum/CurlCode\");\nconst CurlFeature_1 = require(\"./enum/CurlFeature\");\nconst CurlPause_1 = require(\"./enum/CurlPause\");\nconst CurlWriteFunc_1 = require(\"./enum/CurlWriteFunc\");\nconst CurlReadFunc_1 = require(\"./enum/CurlReadFunc\");\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst bindings = require('../lib/binding/node_libcurl.node');\nconst {\n  Curl: _Curl,\n  CurlVersionInfo\n} = bindings;\nif (!process.env.NODE_LIBCURL_DISABLE_GLOBAL_INIT_CALL || process.env.NODE_LIBCURL_DISABLE_GLOBAL_INIT_CALL !== 'true') {\n  // We could just pass nothing here, CurlGlobalInitEnum.All is the default anyway.\n  const globalInitResult = _Curl.globalInit(3 /* All */);\n  assert_1.default(globalInitResult === 0 || 'Libcurl global init failed.');\n}\nconst decoder = new string_decoder_1.StringDecoder('utf8');\n// Handle used by curl instances created by the Curl wrapper.\nconst multiHandle = new Multi_1.Multi();\nconst curlInstanceMap = new WeakMap();\nmultiHandle.onMessage((error, handle, errorCode) => {\n  multiHandle.removeHandle(handle);\n  const curlInstance = curlInstanceMap.get(handle);\n  assert_1.default(curlInstance, 'Could not retrieve curl instance from easy handle on onMessage callback');\n  if (error) {\n    curlInstance.onError(error, errorCode);\n  } else {\n    curlInstance.onEnd();\n  }\n});\n/**\r\n * Wrapper around {@link \"Easy\".Easy | `Easy`} class with a more *nodejs-friendly* interface.\r\n *\r\n * This uses an internal {@link \"Multi\".Multi | `Multi`} instance allowing for asynchronous\r\n * requests.\r\n *\r\n * @public\r\n */\nclass Curl extends events_1.EventEmitter {\n  /**\r\n   * @param cloneHandle {@link \"Easy\".Easy | `Easy`} handle that should be used instead of creating a new one.\r\n   */\n  constructor(cloneHandle) {\n    super();\n    /**\r\n     * Whether this instance is running or not ({@link perform | `perform()`} was called).\r\n     *\r\n     * Make sure to not change their value, otherwise unexpected behavior would happen.\r\n     *\r\n     * This is marked as protected only with the TSDoc to not cause a breaking change.\r\n     *\r\n     * @protected\r\n     */\n    this.isRunning = false;\n    /**\r\n     * Stores current response payload.\r\n     *\r\n     * This will not store anything in case {@link CurlFeature.NoDataStorage | `NoDataStorage`} flag is enabled\r\n     */\n    this.chunks = [];\n    /**\r\n     * Current response length.\r\n     *\r\n     * Will always be zero in case {@link CurlFeature.NoDataStorage | `NoDataStorage`} flag is enabled\r\n     */\n    this.chunksLength = 0;\n    /**\r\n     * Stores current headers payload.\r\n     *\r\n     * This will not store anything in case {@link CurlFeature.NoDataStorage | `NoDataStorage`} flag is enabled\r\n     */\n    this.headerChunks = [];\n    /**\r\n     * Current headers length.\r\n     *\r\n     * Will always be zero in case {@link CurlFeature.NoDataStorage | `NoDataStorage`} flag is enabled\r\n     */\n    this.headerChunksLength = 0;\n    /**\r\n     * Currently enabled features.\r\n     *\r\n     * See {@link enable | `enable`} and {@link disable | `disable`}\r\n     */\n    this.features = 0;\n    // these are for stream handling\n    // the streams themselves\n    this.writeFunctionStream = null;\n    this.readFunctionStream = null;\n    // READFUNCTION / upload related\n    this.streamReadFunctionCallbacksToClean = [];\n    // a state machine would be better here than all these flags ðŸ¤£\n    this.streamReadFunctionShouldEnd = false;\n    this.streamReadFunctionShouldPause = false;\n    this.streamReadFunctionPaused = false;\n    this.streamWriteFunctionShouldPause = false;\n    this.streamWriteFunctionPaused = false;\n    this.streamWriteFunctionFirstRun = true;\n    // common\n    this.streamPauseNext = false;\n    this.streamContinueNext = false;\n    this.streamError = false;\n    this.streamUserSuppliedProgressFunction = null;\n    const handle = cloneHandle || new Easy_1.Easy();\n    this.handle = handle;\n    // callbacks called by libcurl\n    handle.setOpt(Curl.option.WRITEFUNCTION, this.defaultWriteFunction.bind(this));\n    handle.setOpt(Curl.option.HEADERFUNCTION, this.defaultHeaderFunction.bind(this));\n    handle.setOpt(Curl.option.USERAGENT, Curl.defaultUserAgent);\n    curlInstanceMap.set(handle, this);\n  }\n  /**\r\n   * Whether this instance is closed or not ({@link close | `close()`} was called).\r\n   *\r\n   * Make sure to not change their value, otherwise unexpected behavior would happen.\r\n   */\n  get isOpen() {\n    return this.handle.isOpen;\n  }\n  /**\r\n   * Callback called when an error is thrown on this handle.\r\n   *\r\n   * This is called from the internal callback we use with the {@link \"Multi\".Multi.onMessage | `onMessage`}\r\n   *  method of the global {@link \"Multi\".Multi | `Multi`} handle used by all `Curl` instances.\r\n   *\r\n   * @protected\r\n   */\n  onError(error, errorCode) {\n    this.resetInternalState();\n    this.emit('error', error, errorCode, this);\n  }\n  /**\r\n   * Callback called when this handle has finished the request.\r\n   *\r\n   * This is called from the internal callback we use with the {@link \"Multi\".Multi.onMessage | `onMessage`}\r\n   *  method of the global {@link \"Multi\".Multi | `Multi`} handle used by all `Curl` instances.\r\n   *\r\n   * This should not be called in any other way.\r\n   *\r\n   * @protected\r\n   */\n  onEnd() {\n    const isStreamResponse = !!(this.features & CurlFeature_1.CurlFeature.StreamResponse);\n    const isDataStorageEnabled = !isStreamResponse && !(this.features & CurlFeature_1.CurlFeature.NoDataStorage);\n    const isDataParsingEnabled = !isStreamResponse && !(this.features & CurlFeature_1.CurlFeature.NoDataParsing) && isDataStorageEnabled;\n    const dataRaw = isDataStorageEnabled ? mergeChunks_1.mergeChunks(this.chunks, this.chunksLength) : Buffer.alloc(0);\n    const data = isDataParsingEnabled ? decoder.write(dataRaw) : dataRaw;\n    const headers = this.getHeaders();\n    const {\n      code,\n      data: status\n    } = this.handle.getInfo(Curl.info.RESPONSE_CODE);\n    // if this had the stream response flag we need to signal the end of the stream by pushing null to it.\n    if (isStreamResponse) {\n      // if the writeFunctionStream is still null here, this means the response had no body\n      // This may happen because the writeFunctionStream is created in the writeFunction callback, which is not called\n      // for requests that do not have a body\n      if (!this.writeFunctionStream) {\n        // we such cases we must call the on Stream event and immediately signal the end of the stream.\n        const noopStream = new stream_1.Readable({\n          read() {\n            setImmediate(() => {\n              this.push(null);\n            });\n          }\n        });\n        // we are calling this with nextTick because it must run before the next event loop iteration (notice that the cleanup is called with setImmediate below).\n        // We are not just calling it directly to avoid errors in the on Stream callbacks causing this function to throw\n        process.nextTick(() => this.emit('stream', noopStream, status, headers, this));\n      } else {\n        this.writeFunctionStream.push(null);\n      }\n    }\n    const wrapper = isStreamResponse ? setImmediate : fn => fn();\n    wrapper(() => {\n      this.resetInternalState();\n      // if is ignored because this should never happen under normal circumstances.\n      /* istanbul ignore if */\n      if (code !== CurlCode_1.CurlCode.CURLE_OK) {\n        const error = new Error('Could not get status code of request');\n        this.emit('error', error, code, this);\n      } else {\n        this.emit('end', status, data, headers, this);\n      }\n    });\n  }\n  /**\r\n   * Enables a feature, must not be used while a request is running.\r\n   *\r\n   * Use {@link CurlFeature | `CurlFeature`} for predefined constants.\r\n   */\n  enable(bitmask) {\n    if (this.isRunning) {\n      throw new Error('You should not change the features while a request is running.');\n    }\n    this.features |= bitmask;\n    return this;\n  }\n  /**\r\n   * Disables a feature, must not be used while a request is running.\r\n   *\r\n   * Use {@link CurlFeature | `CurlFeature`} for predefined constants.\r\n   */\n  disable(bitmask) {\n    if (this.isRunning) {\n      throw new Error('You should not change the features while a request is running.');\n    }\n    this.features &= ~bitmask;\n    return this;\n  }\n  /**\r\n   * Sets an option the handle.\r\n   *\r\n   * This overloaded method has `never` as type for the arguments\r\n   *  because one of the other overloaded signatures must be used.\r\n   *\r\n   *\r\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\r\n   *\r\n   * @param optionIdOrName Option name or integer value. Use {@link Curl.option | `Curl.option`} for predefined constants.\r\n   * @param optionValue The value of the option, value type depends on the option being set.\r\n   */\n  setOpt(optionIdOrName, optionValue) {\n    // special case for WRITEFUNCTION and HEADERFUNCTION callbacks\n    //  since if they are set back to null, we must restore the default callback.\n    let value = optionValue;\n    if ((optionIdOrName === Curl.option.WRITEFUNCTION || optionIdOrName === 'WRITEFUNCTION') && !optionValue) {\n      value = this.defaultWriteFunction.bind(this);\n    } else if ((optionIdOrName === Curl.option.HEADERFUNCTION || optionIdOrName === 'HEADERFUNCTION') && !optionValue) {\n      value = this.defaultHeaderFunction.bind(this);\n    }\n    const code = this.handle.setOpt(optionIdOrName, value);\n    if (code !== CurlCode_1.CurlCode.CURLE_OK) {\n      throw new Error(code === CurlCode_1.CurlCode.CURLE_UNKNOWN_OPTION ? 'Unknown option given. First argument must be the option internal id or the option name. You can use the Curl.option constants.' : Easy_1.Easy.strError(code));\n    }\n    return this;\n  }\n  /**\r\n   * Retrieves some information about the last request made by a handle.\r\n   *\r\n   * This overloaded method has `never` as type for the argument\r\n   *  because one of the other overloaded signatures must be used.\r\n   *\r\n   * Official libcurl documentation: [`curl_easy_getinfo()`](http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html)\r\n   *\r\n   * @param infoNameOrId Info name or integer value. Use {@link Curl.info | `Curl.info`} for predefined constants.\r\n   */\n  getInfo(infoNameOrId) {\n    const {\n      code,\n      data\n    } = this.handle.getInfo(infoNameOrId);\n    if (code !== CurlCode_1.CurlCode.CURLE_OK) {\n      throw new Error(`getInfo failed. Error: ${Easy_1.Easy.strError(code)}`);\n    }\n    return data;\n  }\n  /**\r\n   * This will set an internal `READFUNCTION` callback that will read all the data from this stream.\r\n   *\r\n   * One usage for that is to upload data directly from streams. Example:\r\n   *\r\n   * ```typescript\r\n   *  const curl = new Curl()\r\n   *  curl.setOpt('URL', 'https://some-domain/upload')\r\n   *  curl.setOpt('UPLOAD', true)\r\n   *  // so we do not need to set the content length\r\n   *  curl.setOpt('HTTPHEADER', ['Transfer-Encoding: chunked'])\r\n   *\r\n   *  const filePath = './test.zip'\r\n   *  const stream = fs.createReadStream(filePath)\r\n   *  curl.setUploadStream(stream)\r\n   *\r\n   *  curl.setStreamProgressCallback(() => {\r\n   *    // this will use the default progress callback from libcurl\r\n   *    return CurlProgressFunc.Continue\r\n   *  })\r\n   *\r\n   *  curl.on('end', (statusCode, data) => {\r\n   *    console.log('\\n'.repeat(5))\r\n   *    // data length should be 0, as it was sent using the response stream\r\n   *    console.log(\r\n   *      `curl - end - status: ${statusCode} - data length: ${data.length}`,\r\n   *    )\r\n   *    curl.close()\r\n   *  })\r\n   *  curl.on('error', (error, errorCode) => {\r\n   *    console.log('\\n'.repeat(5))\r\n   *    console.error('curl - error: ', error, errorCode)\r\n   *    curl.close()\r\n   *  })\r\n   *  curl.perform()\r\n   * ```\r\n   *\r\n   * Multiple calls with the same stream that was previously set has no effect.\r\n   *\r\n   * Setting this to `null` will remove the `READFUNCTION` callback and disable this behavior.\r\n   *\r\n   * @remarks\r\n   *\r\n   * This option is reset after each request, so if you want to upload the same data again using the same\r\n   * `Curl` instance, you will need to provide a new stream.\r\n   *\r\n   * Make sure your libcurl version is greater than or equal 7.69.1.\r\n   * Versions older than that one are not reliable for streams usage.\r\n   */\n  setUploadStream(stream) {\n    if (!stream) {\n      if (this.readFunctionStream) {\n        this.cleanupReadFunctionStreamEvents();\n        this.readFunctionStream = null;\n        this.setOpt('READFUNCTION', null);\n      }\n      return this;\n    }\n    if (this.readFunctionStream === stream) return this;\n    if (typeof (stream === null || stream === void 0 ? void 0 : stream.on) !== 'function' || typeof (stream === null || stream === void 0 ? void 0 : stream.read) !== 'function') {\n      throw new Error('The passed value to setUploadStream does not looks like a stream object');\n    }\n    this.readFunctionStream = stream;\n    const resumeIfPaused = () => {\n      if (this.streamReadFunctionPaused) {\n        this.streamReadFunctionPaused = false;\n        // let's unpause only on the next event loop iteration\n        // this will avoid scenarios where the readable event was emitted\n        // between libcurl pausing the transfer from the READFUNCTION\n        // and the next real iteration.\n        setImmediate(() => {\n          // just to make sure we do not try to unpause\n          // a connection that has already finished\n          // this can happen if some error has been throw\n          // in the meantime\n          if (this.isRunning) {\n            this.pause(CurlPause_1.CurlPause.Cont);\n          }\n        });\n      }\n    };\n    const attachEventListenerToStream = (event, cb) => {\n      this.readFunctionStream.on(event, cb);\n      this.streamReadFunctionCallbacksToClean.push([this.readFunctionStream, event, cb]);\n    };\n    // TODO: Handle adding the event multiple times?\n    // can only happen if the user calls the method with the same stream more than one time\n    // and due to the if at the top, this is only possible if they use another stream in-between.\n    attachEventListenerToStream('readable', () => {\n      resumeIfPaused();\n    });\n    // This needs the same logic than the destroy callback for the response stream\n    // inside the default WRITEFUNCTION.\n    // Which basically means we cannot throw an error inside the READFUNCTION itself\n    // as this would cause the pause itself to throw an error\n    // (pause calls the READFUNCTION before returning)\n    // So we must create a fake \"pause\" just to trigger the progress function, and\n    // then the error will be thrown.\n    // This is why the following two callbacks are setting\n    // this.streamReadFunctionShouldPause = true\n    attachEventListenerToStream('close', () => {\n      // If the stream was closed, but end was not called\n      // it means the stream was forcefully destroyed, so\n      // we must let libcurl fail!\n      // streamError could already be set if destroy was called with an error\n      // as it would call the error callback below, so we don't need to do anything.\n      if (!this.streamReadFunctionShouldEnd && !this.streamError) {\n        this.streamError = new Error('Curl upload stream was unexpectedly destroyed');\n        this.streamReadFunctionShouldPause = true;\n        resumeIfPaused();\n      }\n    });\n    attachEventListenerToStream('error', error => {\n      this.streamError = error;\n      this.streamReadFunctionShouldPause = true;\n      resumeIfPaused();\n    });\n    attachEventListenerToStream('end', () => {\n      this.streamReadFunctionShouldEnd = true;\n      resumeIfPaused();\n    });\n    this.setOpt('READFUNCTION', (buffer, size, nmemb) => {\n      // Remember, we cannot throw this.streamError here.\n      if (this.streamReadFunctionShouldPause) {\n        this.streamReadFunctionShouldPause = false;\n        this.streamReadFunctionPaused = true;\n        return CurlReadFunc_1.CurlReadFunc.Pause;\n      }\n      const amountToRead = size * nmemb;\n      const data = stream.read(amountToRead);\n      if (!data) {\n        if (this.streamReadFunctionShouldEnd) {\n          return 0;\n        } else {\n          this.streamReadFunctionPaused = true;\n          return CurlReadFunc_1.CurlReadFunc.Pause;\n        }\n      }\n      const totalWritten = data.copy(buffer);\n      // we could also return CurlReadFunc.Abort or CurlReadFunc.Pause here.\n      return totalWritten;\n    });\n    return this;\n  }\n  /**\r\n   * Set the param to `null` to use the Node.js default value.\r\n   *\r\n   * @param highWaterMark This will passed directly to the `Readable` stream created to be returned as the response'\r\n   *\r\n   * @remarks\r\n   * Only useful when the {@link CurlFeature.StreamResponse | `StreamResponse`} feature flag is enabled.\r\n   */\n  setStreamResponseHighWaterMark(highWaterMark) {\n    this.streamWriteFunctionHighWaterMark = highWaterMark || undefined;\n    return this;\n  }\n  /**\r\n   * This sets the callback to be used as the progress function when using any of the stream features.\r\n   *\r\n   * This is needed because when this `Curl` instance is enabled to use streams for upload/download, it needs\r\n   * to set the libcurl progress function option to an internal function.\r\n   *\r\n   * If you are using any of the streams features, do not overwrite the progress callback to something else,\r\n   * be it using {@link setOpt | `setOpt`} or {@link setProgressCallback | `setProgressCallback`}, as this would\r\n   * cause undefined behavior.\r\n   *\r\n   * If are using this callback, there is no need to set the `NOPROGRESS` option to false (as you normally would).\r\n   */\n  setStreamProgressCallback(cb) {\n    this.streamUserSuppliedProgressFunction = cb;\n    return this;\n  }\n  /**\r\n   * The option `XFERINFOFUNCTION` was introduced in curl version `7.32.0`,\r\n   *  versions older than that should use `PROGRESSFUNCTION`.\r\n   * If you don't want to mess with version numbers you can use this method,\r\n   * instead of directly calling {@link Curl.setOpt | `Curl#setOpt`}.\r\n   *\r\n   * `NOPROGRESS` should be set to false to make this function actually get called.\r\n   */\n  setProgressCallback(cb) {\n    if (Curl.VERSION_NUM >= 0x072000) {\n      this.handle.setOpt(Curl.option.XFERINFOFUNCTION, cb);\n    } else {\n      this.handle.setOpt(Curl.option.PROGRESSFUNCTION, cb);\n    }\n    return this;\n  }\n  /**\r\n   * Add this instance to the processing queue.\r\n   * This method should be called only one time per request,\r\n   *  otherwise it will throw an error.\r\n   *\r\n   * @remarks\r\n   *\r\n   * This basically calls the {@link \"Multi\".Multi.addHandle | `Multi#addHandle`} method.\r\n   */\n  perform() {\n    if (this.isRunning) {\n      throw new Error('Handle already running!');\n    }\n    this.isRunning = true;\n    // set progress function to our internal one if using stream upload/download\n    const isStreamEnabled = this.features & CurlFeature_1.CurlFeature.StreamResponse || this.readFunctionStream;\n    if (isStreamEnabled) {\n      this.setProgressCallback(this.streamModeProgressFunction.bind(this));\n      this.setOpt('NOPROGRESS', false);\n    }\n    multiHandle.addHandle(this.handle);\n    return this;\n  }\n  /**\r\n   * Perform any connection upkeep checks.\r\n   *\r\n   *\r\n   * Official libcurl documentation: [`curl_easy_upkeep()`](http://curl.haxx.se/libcurl/c/curl_easy_upkeep.html)\r\n   */\n  upkeep() {\n    const code = this.handle.upkeep();\n    if (code !== CurlCode_1.CurlCode.CURLE_OK) {\n      throw new Error(Easy_1.Easy.strError(code));\n    }\n    return this;\n  }\n  /**\r\n   * Use this function to pause / unpause a connection.\r\n   *\r\n   * The bitmask argument is a set of bits that sets the new state of the connection.\r\n   *\r\n   * Use {@link CurlPause | `CurlPause`} for predefined constants.\r\n   *\r\n   *\r\n   * Official libcurl documentation: [`curl_easy_pause()`](http://curl.haxx.se/libcurl/c/curl_easy_pause.html)\r\n   */\n  pause(bitmask) {\n    const code = this.handle.pause(bitmask);\n    if (code !== CurlCode_1.CurlCode.CURLE_OK) {\n      throw new Error(Easy_1.Easy.strError(code));\n    }\n    return this;\n  }\n  /**\r\n   * Reset this handle options to their defaults.\r\n   *\r\n   * This will put the handle in a clean state, as if it was just created.\r\n   *\r\n   *\r\n   * Official libcurl documentation: [`curl_easy_reset()`](http://curl.haxx.se/libcurl/c/curl_easy_reset.html)\r\n   */\n  reset() {\n    this.removeAllListeners();\n    this.handle.reset();\n    // add callbacks back as reset will remove them\n    this.handle.setOpt(Curl.option.WRITEFUNCTION, this.defaultWriteFunction.bind(this));\n    this.handle.setOpt(Curl.option.HEADERFUNCTION, this.defaultHeaderFunction.bind(this));\n    return this;\n  }\n  /**\r\n   * Duplicate this handle with all their options.\r\n   * Keep in mind that, by default, this also means all event listeners.\r\n   *\r\n   *\r\n   * Official libcurl documentation: [`curl_easy_duphandle()`](http://curl.haxx.se/libcurl/c/curl_easy_duphandle.html)\r\n   *\r\n   * @param shouldCopyEventListeners If you don't want to copy the event listeners, set this to `false`.\r\n   */\n  dupHandle() {\n    let shouldCopyEventListeners = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const duplicatedHandle = new Curl(this.handle.dupHandle());\n    const eventsToCopy = ['end', 'error', 'data', 'header'];\n    duplicatedHandle.features = this.features;\n    if (shouldCopyEventListeners) {\n      for (let i = 0; i < eventsToCopy.length; i += 1) {\n        const listeners = this.listeners(eventsToCopy[i]);\n        for (let j = 0; j < listeners.length; j += 1) {\n          duplicatedHandle.on(eventsToCopy[i], listeners[j]);\n        }\n      }\n    }\n    return duplicatedHandle;\n  }\n  /**\r\n   * Close this handle.\r\n   *\r\n   * **NOTE:** After closing the handle, it must not be used anymore. Doing so will throw an error.\r\n   *\r\n   *\r\n   * Official libcurl documentation: [`curl_easy_cleanup()`](http://curl.haxx.se/libcurl/c/curl_easy_cleanup.html)\r\n   */\n  close() {\n    // TODO(jonathan): on next semver major check if this.handle.isOpen is false and if it is, return immediately.\n    curlInstanceMap.delete(this.handle);\n    this.removeAllListeners();\n    if (this.handle.isInsideMultiHandle) {\n      multiHandle.removeHandle(this.handle);\n    }\n    this.handle.setOpt(Curl.option.WRITEFUNCTION, null);\n    this.handle.setOpt(Curl.option.HEADERFUNCTION, null);\n    this.handle.close();\n  }\n  /**\r\n   * This is used to reset a few properties to their pre-request state.\r\n   */\n  resetInternalState() {\n    this.isRunning = false;\n    this.chunks = [];\n    this.chunksLength = 0;\n    this.headerChunks = [];\n    this.headerChunksLength = 0;\n    const wasStreamEnabled = this.writeFunctionStream || this.readFunctionStream;\n    if (wasStreamEnabled) {\n      this.setProgressCallback(null);\n    }\n    // reset back the READFUNCTION if there was a stream we were reading from\n    if (this.readFunctionStream) {\n      this.setOpt('READFUNCTION', null);\n    }\n    // these are mostly streams related, as these options are not persisted between requests\n    // the streams themselves\n    this.writeFunctionStream = null;\n    this.readFunctionStream = null;\n    // READFUNCTION / upload related\n    this.streamReadFunctionShouldEnd = false;\n    this.streamReadFunctionShouldPause = false;\n    this.streamReadFunctionPaused = false;\n    // WRITEFUNCTION / download related\n    this.streamWriteFunctionShouldPause = false;\n    this.streamWriteFunctionPaused = false;\n    this.streamWriteFunctionFirstRun = true;\n    // common\n    this.streamPauseNext = false;\n    this.streamContinueNext = false;\n    this.streamError = false;\n    this.streamUserSuppliedProgressFunction = null;\n    this.cleanupReadFunctionStreamEvents();\n  }\n  /**\r\n   * When uploading a stream (by calling {@link setUploadStream | `setUploadStream`})\r\n   * some event listeners are attached to the stream instance.\r\n   * This will remove them so our callbacks are not called anymore.\r\n   */\n  cleanupReadFunctionStreamEvents() {\n    this.streamReadFunctionCallbacksToClean.forEach(_ref => {\n      let [stream, event, cb] = _ref;\n      stream.off(event, cb);\n    });\n    this.streamReadFunctionCallbacksToClean = [];\n  }\n  /**\r\n   * Returns headers from the current stored chunks - if any\r\n   */\n  getHeaders() {\n    const isHeaderStorageEnabled = !(this.features & CurlFeature_1.CurlFeature.NoHeaderStorage);\n    const isHeaderParsingEnabled = !(this.features & CurlFeature_1.CurlFeature.NoHeaderParsing) && isHeaderStorageEnabled;\n    const headersRaw = isHeaderStorageEnabled ? mergeChunks_1.mergeChunks(this.headerChunks, this.headerChunksLength) : Buffer.alloc(0);\n    return isHeaderParsingEnabled ? parseHeaders_1.parseHeaders(decoder.write(headersRaw)) : headersRaw;\n  }\n  /**\r\n   * The internal function passed to `PROGRESSFUNCTION` (`XFERINFOFUNCTION` on most recent libcurl versions)\r\n   * when using any of the stream features.\r\n   */\n  streamModeProgressFunction(dltotal, dlnow, ultotal, ulnow) {\n    if (this.streamError) throw this.streamError;\n    const ret = this.streamUserSuppliedProgressFunction ? this.streamUserSuppliedProgressFunction.call(this.handle, dltotal, dlnow, ultotal, ulnow) : 0;\n    return ret;\n  }\n  /**\r\n   * This is the default callback passed to {@link setOpt | `setOpt('WRITEFUNCTION', cb)`}.\r\n   */\n  defaultWriteFunction(chunk, size, nmemb) {\n    // this is a stream based request, so we need a totally different handling\n    if (this.features & CurlFeature_1.CurlFeature.StreamResponse) {\n      return this.defaultWriteFunctionStreamBased(chunk, size, nmemb);\n    }\n    if (!(this.features & CurlFeature_1.CurlFeature.NoDataStorage)) {\n      this.chunks.push(chunk);\n      this.chunksLength += chunk.length;\n    }\n    this.emit('data', chunk, this);\n    return size * nmemb;\n  }\n  /**\r\n   * This is used by the default callback passed to {@link setOpt | `setOpt('WRITEFUNCTION', cb)`}\r\n   * when the feature to stream response is enabled.\r\n   */\n  defaultWriteFunctionStreamBased(chunk, size, nmemb) {\n    if (!this.writeFunctionStream) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const handle = this;\n      // create the response stream we are going to use\n      this.writeFunctionStream = new stream_1.Readable({\n        highWaterMark: this.streamWriteFunctionHighWaterMark,\n        destroy(error, cb) {\n          handle.streamError = error || new Error('Curl response stream was unexpectedly destroyed');\n          // let the event loop run one more time before we do anything\n          // if the handle is not running anymore it means that the\n          // error we set above was caught, if it is still running, then it means that:\n          // - the handle is paused\n          // - the progress function was not called yet\n          // If this is the case, then we just unpause the handle. This will cause the following:\n          // - the WRITEFUNCTION callback will be called\n          // - this will pause the handle again (because we cannot throw the error in here)\n          // - the PROGRESSFUNCTION callback will be called, and then the error will be thrown.\n          setImmediate(() => {\n            if (handle.isRunning && handle.streamWriteFunctionPaused) {\n              handle.streamWriteFunctionPaused = false;\n              handle.streamWriteFunctionShouldPause = true;\n              try {\n                handle.pause(CurlPause_1.CurlPause.RecvCont);\n              } catch (error) {\n                cb(error);\n                return;\n              }\n            }\n            cb(null);\n          });\n        },\n        read(_size) {\n          if (handle.streamWriteFunctionFirstRun || handle.streamWriteFunctionPaused) {\n            if (handle.streamWriteFunctionFirstRun) {\n              handle.streamWriteFunctionFirstRun = false;\n            }\n            // we must allow Node.js to process the whole event queue\n            // before we unpause\n            setImmediate(() => {\n              if (handle.isRunning) {\n                handle.streamWriteFunctionPaused = false;\n                handle.pause(CurlPause_1.CurlPause.RecvCont);\n              }\n            });\n          }\n        }\n      });\n      // as soon as we have the stream, we need to emit the \"stream\" event\n      // but the \"stream\" event needs the statusCode and the headers, so this\n      // is what we are retrieving here.\n      const headers = this.getHeaders();\n      const {\n        code,\n        data: status\n      } = this.handle.getInfo(Curl.info.RESPONSE_CODE);\n      if (code !== CurlCode_1.CurlCode.CURLE_OK) {\n        const error = new Error('Could not get status code of request');\n        this.emit('error', error, code, this);\n        return 0;\n      }\n      // let's emit the event only in the next iteration of the event loop\n      // We need to do this otherwise the event listener callbacks would run\n      // before the pause below, and this is probably not what we want.\n      setImmediate(() => this.emit('stream', this.writeFunctionStream, status, headers, this));\n      this.streamWriteFunctionPaused = true;\n      return CurlWriteFunc_1.CurlWriteFunc.Pause;\n    }\n    // pause this req\n    if (this.streamWriteFunctionShouldPause) {\n      this.streamWriteFunctionShouldPause = false;\n      this.streamWriteFunctionPaused = true;\n      return CurlWriteFunc_1.CurlWriteFunc.Pause;\n    }\n    // write to the stream\n    const ok = this.writeFunctionStream.push(chunk);\n    // pause connection until there is more data\n    if (!ok) {\n      this.streamWriteFunctionPaused = true;\n      this.pause(CurlPause_1.CurlPause.Recv);\n    }\n    return size * nmemb;\n  }\n  /**\r\n   * This is the default callback passed to {@link setOpt | `setOpt('HEADERFUNCTION', cb)`}.\r\n   */\n  defaultHeaderFunction(chunk, size, nmemb) {\n    if (!(this.features & CurlFeature_1.CurlFeature.NoHeaderStorage)) {\n      this.headerChunks.push(chunk);\n      this.headerChunksLength += chunk.length;\n    }\n    this.emit('header', chunk, this);\n    return size * nmemb;\n  }\n}\nexports.Curl = Curl;\n/**\r\n * Calls [`curl_global_init()`](http://curl.haxx.se/libcurl/c/curl_global_init.html).\r\n *\r\n * For **flags** see the the enum {@link CurlGlobalInit | `CurlGlobalInit`}.\r\n *\r\n * This is automatically called when the addon is loaded, to disable this, set the environment variable\r\n *  `NODE_LIBCURL_DISABLE_GLOBAL_INIT_CALL=false`\r\n */\nCurl.globalInit = _Curl.globalInit;\n/**\r\n * Calls [`curl_global_cleanup()`](http://curl.haxx.se/libcurl/c/curl_global_cleanup.html)\r\n *\r\n * This is automatically called when the process is exiting.\r\n */\nCurl.globalCleanup = _Curl.globalCleanup;\n/**\r\n * Returns libcurl version string.\r\n *\r\n * The string shows which libraries libcurl was built with and their versions, example:\r\n * ```\r\n * libcurl/7.69.1-DEV OpenSSL/1.1.1d zlib/1.2.11 WinIDN libssh2/1.9.0_DEV nghttp2/1.40.0\r\n * ```\r\n */\nCurl.getVersion = _Curl.getVersion;\n/**\r\n * This is the default user agent that is going to be used on all `Curl` instances.\r\n *\r\n * You can overwrite this in a per instance basis, calling `curlHandle.setOpt('USERAGENT', 'my-user-agent/1.0')`, or\r\n *  by directly changing this property so it affects all newly created `Curl` instances.\r\n *\r\n * To disable this behavior set this property to `null`.\r\n */\nCurl.defaultUserAgent = `node-libcurl/${pkg.version}`;\n/**\r\n * Integer representing the current libcurl version.\r\n *\r\n * It was built the following way:\r\n * ```\r\n * <8 bits major number> | <8 bits minor number> | <8 bits patch number>.\r\n * ```\r\n * Version `7.69.1` is therefore returned as `0x074501` / `476417`\r\n */\nCurl.VERSION_NUM = _Curl.VERSION_NUM;\n/**\r\n * This is a object with members resembling the `CURLINFO_*` libcurl constants.\r\n *\r\n * It can be used with {@link \"Easy\".Easy.getInfo | `Easy#getInfo`} or {@link getInfo | `Curl#getInfo`}.\r\n *\r\n * See the official documentation of [`curl_easy_getinfo()`](http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html)\r\n *  for reference.\r\n *\r\n * `CURLINFO_EFFECTIVE_URL` becomes `Curl.info.EFFECTIVE_URL`\r\n */\nCurl.info = _Curl.info;\n/**\r\n * This is a object with members resembling the `CURLOPT_*` libcurl constants.\r\n *\r\n * It can be used with {@link \"Easy\".Easy.setOpt | `Easy#setOpt`} or {@link setOpt | `Curl#setOpt`}.\r\n *\r\n * See the official documentation of [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\r\n *  for reference.\r\n *\r\n * `CURLOPT_URL` becomes `Curl.option.URL`\r\n */\nCurl.option = _Curl.option;\n/**\r\n * Returns the number of handles currently open in the internal {@link \"Multi\".Multi | `Multi`} handle being used.\r\n */\nCurl.getCount = multiHandle.getCount;\n/**\r\n * Returns an object with a representation of the current libcurl version and their features/protocols.\r\n *\r\n * This is basically [`curl_version_info()`](https://curl.haxx.se/libcurl/c/curl_version_info.html)\r\n */\nCurl.getVersionInfo = () => CurlVersionInfo;\n/**\r\n * Returns a string that looks like the one returned by\r\n * ```bash\r\n * curl -V\r\n * ```\r\n * Example:\r\n * ```\r\n * Version: libcurl/7.69.1-DEV OpenSSL/1.1.1d zlib/1.2.11 WinIDN libssh2/1.9.0_DEV nghttp2/1.40.0\r\n * Protocols: dict, file, ftp, ftps, gopher, http, https, imap, imaps, ldap, ldaps, pop3, pop3s, rtsp, scp, sftp, smb, smbs, smtp, smtps, telnet, tftp\r\n * Features: AsynchDNS, IDN, IPv6, Largefile, SSPI, Kerberos, SPNEGO, NTLM, SSL, libz, HTTP2, HTTPS-proxy\r\n * ```\r\n */\nCurl.getVersionInfoString = () => {\n  const version = Curl.getVersion();\n  const protocols = CurlVersionInfo.protocols.join(', ');\n  const features = CurlVersionInfo.features.join(', ');\n  return [`Version: ${version}`, `Protocols: ${protocols}`, `Features: ${features}`].join('\\n');\n};\n/**\r\n * Useful if you want to check if the current libcurl version is greater or equal than another one.\r\n * @param x major\r\n * @param y minor\r\n * @param z patch\r\n */\nCurl.isVersionGreaterOrEqualThan = function (x, y) {\n  let z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return _Curl.VERSION_NUM >= (x << 16) + (y << 8) + z;\n};","map":{"version":3,"names":["events_1","require","string_decoder_1","assert_1","tslib_1","__importDefault","stream_1","pkg","Easy_1","Multi_1","mergeChunks_1","parseHeaders_1","CurlCode_1","CurlFeature_1","CurlPause_1","CurlWriteFunc_1","CurlReadFunc_1","bindings","Curl","_Curl","CurlVersionInfo","process","env","NODE_LIBCURL_DISABLE_GLOBAL_INIT_CALL","globalInitResult","globalInit","default","decoder","StringDecoder","multiHandle","Multi","curlInstanceMap","WeakMap","onMessage","error","handle","errorCode","removeHandle","curlInstance","get","onError","onEnd","EventEmitter","constructor","cloneHandle","isRunning","chunks","chunksLength","headerChunks","headerChunksLength","features","writeFunctionStream","readFunctionStream","streamReadFunctionCallbacksToClean","streamReadFunctionShouldEnd","streamReadFunctionShouldPause","streamReadFunctionPaused","streamWriteFunctionShouldPause","streamWriteFunctionPaused","streamWriteFunctionFirstRun","streamPauseNext","streamContinueNext","streamError","streamUserSuppliedProgressFunction","Easy","setOpt","option","WRITEFUNCTION","defaultWriteFunction","bind","HEADERFUNCTION","defaultHeaderFunction","USERAGENT","defaultUserAgent","set","isOpen","resetInternalState","emit","isStreamResponse","CurlFeature","StreamResponse","isDataStorageEnabled","NoDataStorage","isDataParsingEnabled","NoDataParsing","dataRaw","mergeChunks","Buffer","alloc","data","write","headers","getHeaders","code","status","getInfo","info","RESPONSE_CODE","noopStream","Readable","read","setImmediate","push","nextTick","wrapper","fn","CurlCode","CURLE_OK","Error","enable","bitmask","disable","optionIdOrName","optionValue","value","CURLE_UNKNOWN_OPTION","strError","infoNameOrId","setUploadStream","stream","cleanupReadFunctionStreamEvents","on","resumeIfPaused","pause","CurlPause","Cont","attachEventListenerToStream","event","cb","buffer","size","nmemb","CurlReadFunc","Pause","amountToRead","totalWritten","copy","setStreamResponseHighWaterMark","highWaterMark","streamWriteFunctionHighWaterMark","undefined","setStreamProgressCallback","setProgressCallback","VERSION_NUM","XFERINFOFUNCTION","PROGRESSFUNCTION","perform","isStreamEnabled","streamModeProgressFunction","addHandle","upkeep","reset","removeAllListeners","dupHandle","shouldCopyEventListeners","arguments","length","duplicatedHandle","eventsToCopy","i","listeners","j","close","delete","isInsideMultiHandle","wasStreamEnabled","forEach","_ref","off","isHeaderStorageEnabled","NoHeaderStorage","isHeaderParsingEnabled","NoHeaderParsing","headersRaw","parseHeaders","dltotal","dlnow","ultotal","ulnow","ret","call","chunk","defaultWriteFunctionStreamBased","destroy","RecvCont","_size","CurlWriteFunc","ok","Recv","exports","globalCleanup","getVersion","version","getCount","getVersionInfo","getVersionInfoString","protocols","join","isVersionGreaterOrEqualThan","x","y","z"],"sources":["D:\\Rabbil Laravel\\Ecommerce-Project\\Ecommerse-User\\node_modules\\node-libcurl\\lib\\Curl.ts"],"sourcesContent":["/**\n * Copyright (c) Jonathan Cardoso Machado. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { EventEmitter } from 'events'\nimport { StringDecoder } from 'string_decoder'\nimport assert from 'assert'\nimport { Readable } from 'stream'\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst pkg = require('../package.json')\n\nimport {\n  NodeLibcurlNativeBinding,\n  EasyNativeBinding,\n  FileInfo,\n  HttpPostField,\n} from './types'\n\nimport { Easy } from './Easy'\nimport { Multi } from './Multi'\nimport { Share } from './Share'\nimport { mergeChunks } from './mergeChunks'\nimport { parseHeaders, HeaderInfo } from './parseHeaders'\nimport {\n  DataCallbackOptions,\n  ProgressCallbackOptions,\n  StringListOptions,\n  BlobOptions,\n  CurlOptionName,\n  SpecificOptions,\n  CurlOptionValueType,\n} from './generated/CurlOption'\nimport { CurlInfoName } from './generated/CurlInfo'\n\nimport { CurlChunk } from './enum/CurlChunk'\nimport { CurlCode } from './enum/CurlCode'\nimport { CurlFeature } from './enum/CurlFeature'\nimport { CurlFnMatchFunc } from './enum/CurlFnMatchFunc'\nimport { CurlFtpMethod } from './enum/CurlFtpMethod'\nimport { CurlFtpSsl } from './enum/CurlFtpSsl'\nimport { CurlGlobalInit } from './enum/CurlGlobalInit'\nimport { CurlGssApi } from './enum/CurlGssApi'\nimport { CurlHeader } from './enum/CurlHeader'\nimport {\n  CurlHsts,\n  CurlHstsCacheEntry,\n  CurlHstsCacheCount,\n} from './enum/CurlHsts'\nimport { CurlHttpVersion } from './enum/CurlHttpVersion'\nimport { CurlInfoDebug } from './enum/CurlInfoDebug'\nimport { CurlIpResolve } from './enum/CurlIpResolve'\nimport { CurlNetrc } from './enum/CurlNetrc'\nimport { CurlPause } from './enum/CurlPause'\nimport { CurlProgressFunc } from './enum/CurlProgressFunc'\nimport { CurlProtocol } from './enum/CurlProtocol'\nimport { CurlProxy } from './enum/CurlProxy'\nimport { CurlRtspRequest } from './enum/CurlRtspRequest'\nimport { CurlSshAuth } from './enum/CurlSshAuth'\nimport { CurlSslOpt } from './enum/CurlSslOpt'\nimport { CurlSslVersion } from './enum/CurlSslVersion'\nimport { CurlTimeCond } from './enum/CurlTimeCond'\nimport { CurlUseSsl } from './enum/CurlUseSsl'\nimport { CurlWriteFunc } from './enum/CurlWriteFunc'\nimport { CurlReadFunc } from './enum/CurlReadFunc'\nimport { CurlInfoNameSpecific, GetInfoReturn } from './types/EasyNativeBinding'\n\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst bindings: NodeLibcurlNativeBinding = require('../lib/binding/node_libcurl.node')\n\nconst { Curl: _Curl, CurlVersionInfo } = bindings\n\nif (\n  !process.env.NODE_LIBCURL_DISABLE_GLOBAL_INIT_CALL ||\n  process.env.NODE_LIBCURL_DISABLE_GLOBAL_INIT_CALL !== 'true'\n) {\n  // We could just pass nothing here, CurlGlobalInitEnum.All is the default anyway.\n  const globalInitResult = _Curl.globalInit(CurlGlobalInit.All)\n  assert(globalInitResult === 0 || 'Libcurl global init failed.')\n}\n\nconst decoder = new StringDecoder('utf8')\n// Handle used by curl instances created by the Curl wrapper.\nconst multiHandle = new Multi()\nconst curlInstanceMap = new WeakMap<EasyNativeBinding, Curl>()\n\nmultiHandle.onMessage((error, handle, errorCode) => {\n  multiHandle.removeHandle(handle)\n\n  const curlInstance = curlInstanceMap.get(handle)\n\n  assert(\n    curlInstance,\n    'Could not retrieve curl instance from easy handle on onMessage callback',\n  )\n\n  if (error) {\n    curlInstance!.onError(error, errorCode)\n  } else {\n    curlInstance!.onEnd()\n  }\n})\n\n/**\n * Wrapper around {@link \"Easy\".Easy | `Easy`} class with a more *nodejs-friendly* interface.\n *\n * This uses an internal {@link \"Multi\".Multi | `Multi`} instance allowing for asynchronous\n * requests.\n *\n * @public\n */\nclass Curl extends EventEmitter {\n  /**\n   * Calls [`curl_global_init()`](http://curl.haxx.se/libcurl/c/curl_global_init.html).\n   *\n   * For **flags** see the the enum {@link CurlGlobalInit | `CurlGlobalInit`}.\n   *\n   * This is automatically called when the addon is loaded, to disable this, set the environment variable\n   *  `NODE_LIBCURL_DISABLE_GLOBAL_INIT_CALL=false`\n   */\n  static globalInit = _Curl.globalInit\n\n  /**\n   * Calls [`curl_global_cleanup()`](http://curl.haxx.se/libcurl/c/curl_global_cleanup.html)\n   *\n   * This is automatically called when the process is exiting.\n   */\n  static globalCleanup = _Curl.globalCleanup\n\n  /**\n   * Returns libcurl version string.\n   *\n   * The string shows which libraries libcurl was built with and their versions, example:\n   * ```\n   * libcurl/7.69.1-DEV OpenSSL/1.1.1d zlib/1.2.11 WinIDN libssh2/1.9.0_DEV nghttp2/1.40.0\n   * ```\n   */\n  static getVersion = _Curl.getVersion\n\n  /**\n   * This is the default user agent that is going to be used on all `Curl` instances.\n   *\n   * You can overwrite this in a per instance basis, calling `curlHandle.setOpt('USERAGENT', 'my-user-agent/1.0')`, or\n   *  by directly changing this property so it affects all newly created `Curl` instances.\n   *\n   * To disable this behavior set this property to `null`.\n   */\n  static defaultUserAgent = `node-libcurl/${pkg.version}`\n\n  /**\n   * Integer representing the current libcurl version.\n   *\n   * It was built the following way:\n   * ```\n   * <8 bits major number> | <8 bits minor number> | <8 bits patch number>.\n   * ```\n   * Version `7.69.1` is therefore returned as `0x074501` / `476417`\n   */\n  static VERSION_NUM = _Curl.VERSION_NUM\n\n  /**\n   * This is a object with members resembling the `CURLINFO_*` libcurl constants.\n   *\n   * It can be used with {@link \"Easy\".Easy.getInfo | `Easy#getInfo`} or {@link getInfo | `Curl#getInfo`}.\n   *\n   * See the official documentation of [`curl_easy_getinfo()`](http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html)\n   *  for reference.\n   *\n   * `CURLINFO_EFFECTIVE_URL` becomes `Curl.info.EFFECTIVE_URL`\n   */\n  static info = _Curl.info\n\n  /**\n   * This is a object with members resembling the `CURLOPT_*` libcurl constants.\n   *\n   * It can be used with {@link \"Easy\".Easy.setOpt | `Easy#setOpt`} or {@link setOpt | `Curl#setOpt`}.\n   *\n   * See the official documentation of [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   *  for reference.\n   *\n   * `CURLOPT_URL` becomes `Curl.option.URL`\n   */\n  static option = _Curl.option\n\n  /**\n   * Returns the number of handles currently open in the internal {@link \"Multi\".Multi | `Multi`} handle being used.\n   */\n  static getCount = multiHandle.getCount\n\n  /**\n   * Whether this instance is running or not ({@link perform | `perform()`} was called).\n   *\n   * Make sure to not change their value, otherwise unexpected behavior would happen.\n   *\n   * This is marked as protected only with the TSDoc to not cause a breaking change.\n   *\n   * @protected\n   */\n  isRunning = false\n\n  /**\n   * Whether this instance is closed or not ({@link close | `close()`} was called).\n   *\n   * Make sure to not change their value, otherwise unexpected behavior would happen.\n   */\n  get isOpen() {\n    return this.handle.isOpen\n  }\n\n  /**\n   * Internal Easy handle being used\n   */\n  protected handle: EasyNativeBinding\n\n  /**\n   * Stores current response payload.\n   *\n   * This will not store anything in case {@link CurlFeature.NoDataStorage | `NoDataStorage`} flag is enabled\n   */\n  protected chunks: Buffer[] = []\n  /**\n   * Current response length.\n   *\n   * Will always be zero in case {@link CurlFeature.NoDataStorage | `NoDataStorage`} flag is enabled\n   */\n  protected chunksLength = 0\n\n  /**\n   * Stores current headers payload.\n   *\n   * This will not store anything in case {@link CurlFeature.NoDataStorage | `NoDataStorage`} flag is enabled\n   */\n  protected headerChunks: Buffer[] = []\n  /**\n   * Current headers length.\n   *\n   * Will always be zero in case {@link CurlFeature.NoDataStorage | `NoDataStorage`} flag is enabled\n   */\n  protected headerChunksLength = 0\n\n  /**\n   * Currently enabled features.\n   *\n   * See {@link enable | `enable`} and {@link disable | `disable`}\n   */\n  protected features: CurlFeature = 0\n\n  // these are for stream handling\n  // the streams themselves\n  protected writeFunctionStream: Readable | null = null\n  protected readFunctionStream: Readable | null = null\n\n  // READFUNCTION / upload related\n  protected streamReadFunctionCallbacksToClean: Array<\n    [Readable, string, (...args: any[]) => void]\n  > = []\n  // a state machine would be better here than all these flags ðŸ¤£\n  protected streamReadFunctionShouldEnd = false\n  protected streamReadFunctionShouldPause = false\n  protected streamReadFunctionPaused = false\n  // WRITEFUNCTION / download related\n  protected streamWriteFunctionHighWaterMark: number | undefined\n  protected streamWriteFunctionShouldPause = false\n  protected streamWriteFunctionPaused = false\n  protected streamWriteFunctionFirstRun = true\n  // common\n  protected streamPauseNext = false\n  protected streamContinueNext = false\n  protected streamError: false | Error = false\n  protected streamUserSuppliedProgressFunction: CurlOptionValueType['xferInfoFunction'] = null\n\n  /**\n   * @param cloneHandle {@link \"Easy\".Easy | `Easy`} handle that should be used instead of creating a new one.\n   */\n  constructor(cloneHandle?: EasyNativeBinding) {\n    super()\n\n    const handle = cloneHandle || new Easy()\n\n    this.handle = handle\n\n    // callbacks called by libcurl\n    handle.setOpt(\n      Curl.option.WRITEFUNCTION,\n      this.defaultWriteFunction.bind(this),\n    )\n    handle.setOpt(\n      Curl.option.HEADERFUNCTION,\n      this.defaultHeaderFunction.bind(this),\n    )\n\n    handle.setOpt(Curl.option.USERAGENT, Curl.defaultUserAgent)\n\n    curlInstanceMap.set(handle, this)\n  }\n\n  /**\n   * Callback called when an error is thrown on this handle.\n   *\n   * This is called from the internal callback we use with the {@link \"Multi\".Multi.onMessage | `onMessage`}\n   *  method of the global {@link \"Multi\".Multi | `Multi`} handle used by all `Curl` instances.\n   *\n   * @protected\n   */\n  onError(error: Error, errorCode: CurlCode) {\n    this.resetInternalState()\n\n    this.emit('error', error, errorCode, this)\n  }\n\n  /**\n   * Callback called when this handle has finished the request.\n   *\n   * This is called from the internal callback we use with the {@link \"Multi\".Multi.onMessage | `onMessage`}\n   *  method of the global {@link \"Multi\".Multi | `Multi`} handle used by all `Curl` instances.\n   *\n   * This should not be called in any other way.\n   *\n   * @protected\n   */\n  onEnd() {\n    const isStreamResponse = !!(this.features & CurlFeature.StreamResponse)\n    const isDataStorageEnabled =\n      !isStreamResponse && !(this.features & CurlFeature.NoDataStorage)\n    const isDataParsingEnabled =\n      !isStreamResponse &&\n      !(this.features & CurlFeature.NoDataParsing) &&\n      isDataStorageEnabled\n\n    const dataRaw = isDataStorageEnabled\n      ? mergeChunks(this.chunks, this.chunksLength)\n      : Buffer.alloc(0)\n\n    const data = isDataParsingEnabled ? decoder.write(dataRaw) : dataRaw\n    const headers = this.getHeaders()\n\n    const { code, data: status } = this.handle.getInfo(Curl.info.RESPONSE_CODE)\n\n    // if this had the stream response flag we need to signal the end of the stream by pushing null to it.\n    if (isStreamResponse) {\n      // if the writeFunctionStream is still null here, this means the response had no body\n      // This may happen because the writeFunctionStream is created in the writeFunction callback, which is not called\n      // for requests that do not have a body\n      if (!this.writeFunctionStream) {\n        // we such cases we must call the on Stream event and immediately signal the end of the stream.\n        const noopStream = new Readable({\n          read() {\n            setImmediate(() => {\n              this.push(null)\n            })\n          },\n        })\n\n        // we are calling this with nextTick because it must run before the next event loop iteration (notice that the cleanup is called with setImmediate below).\n        // We are not just calling it directly to avoid errors in the on Stream callbacks causing this function to throw\n        process.nextTick(() =>\n          this.emit('stream', noopStream, status, headers, this),\n        )\n      } else {\n        this.writeFunctionStream.push(null)\n      }\n    }\n\n    const wrapper = isStreamResponse\n      ? setImmediate\n      : (fn: (...args: any[]) => void) => fn()\n\n    wrapper(() => {\n      this.resetInternalState()\n\n      // if is ignored because this should never happen under normal circumstances.\n      /* istanbul ignore if */\n      if (code !== CurlCode.CURLE_OK) {\n        const error = new Error('Could not get status code of request')\n        this.emit('error', error, code, this)\n      } else {\n        this.emit('end', status, data, headers, this)\n      }\n    })\n  }\n\n  /**\n   * Enables a feature, must not be used while a request is running.\n   *\n   * Use {@link CurlFeature | `CurlFeature`} for predefined constants.\n   */\n  enable(bitmask: CurlFeature) {\n    if (this.isRunning) {\n      throw new Error(\n        'You should not change the features while a request is running.',\n      )\n    }\n\n    this.features |= bitmask\n\n    return this\n  }\n\n  /**\n   * Disables a feature, must not be used while a request is running.\n   *\n   * Use {@link CurlFeature | `CurlFeature`} for predefined constants.\n   */\n  disable(bitmask: CurlFeature) {\n    if (this.isRunning) {\n      throw new Error(\n        'You should not change the features while a request is running.',\n      )\n    }\n\n    this.features &= ~bitmask\n\n    return this\n  }\n\n  /**\n   * Sets an option the handle.\n   *\n   * This overloaded method has `never` as type for the arguments\n   *  because one of the other overloaded signatures must be used.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   *\n   * @param optionIdOrName Option name or integer value. Use {@link Curl.option | `Curl.option`} for predefined constants.\n   * @param optionValue The value of the option, value type depends on the option being set.\n   */\n  setOpt(optionIdOrName: never, optionValue: never): this {\n    // special case for WRITEFUNCTION and HEADERFUNCTION callbacks\n    //  since if they are set back to null, we must restore the default callback.\n    let value = optionValue\n    if (\n      (optionIdOrName === Curl.option.WRITEFUNCTION ||\n        optionIdOrName === 'WRITEFUNCTION') &&\n      !optionValue\n    ) {\n      value = this.defaultWriteFunction.bind(this) as never\n    } else if (\n      (optionIdOrName === Curl.option.HEADERFUNCTION ||\n        optionIdOrName === 'HEADERFUNCTION') &&\n      !optionValue\n    ) {\n      value = this.defaultHeaderFunction.bind(this) as never\n    }\n\n    const code = this.handle.setOpt(optionIdOrName, value)\n\n    if (code !== CurlCode.CURLE_OK) {\n      throw new Error(\n        code === CurlCode.CURLE_UNKNOWN_OPTION\n          ? 'Unknown option given. First argument must be the option internal id or the option name. You can use the Curl.option constants.'\n          : Easy.strError(code),\n      )\n    }\n\n    return this\n  }\n\n  /**\n   * Retrieves some information about the last request made by a handle.\n   *\n   * This overloaded method has `never` as type for the argument\n   *  because one of the other overloaded signatures must be used.\n   *\n   * Official libcurl documentation: [`curl_easy_getinfo()`](http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html)\n   *\n   * @param infoNameOrId Info name or integer value. Use {@link Curl.info | `Curl.info`} for predefined constants.\n   */\n  getInfo(infoNameOrId: never): any {\n    const { code, data } = this.handle.getInfo(infoNameOrId)\n\n    if (code !== CurlCode.CURLE_OK) {\n      throw new Error(`getInfo failed. Error: ${Easy.strError(code)}`)\n    }\n\n    return data\n  }\n\n  /**\n   * This will set an internal `READFUNCTION` callback that will read all the data from this stream.\n   *\n   * One usage for that is to upload data directly from streams. Example:\n   *\n   * ```typescript\n   *  const curl = new Curl()\n   *  curl.setOpt('URL', 'https://some-domain/upload')\n   *  curl.setOpt('UPLOAD', true)\n   *  // so we do not need to set the content length\n   *  curl.setOpt('HTTPHEADER', ['Transfer-Encoding: chunked'])\n   *\n   *  const filePath = './test.zip'\n   *  const stream = fs.createReadStream(filePath)\n   *  curl.setUploadStream(stream)\n   *\n   *  curl.setStreamProgressCallback(() => {\n   *    // this will use the default progress callback from libcurl\n   *    return CurlProgressFunc.Continue\n   *  })\n   *\n   *  curl.on('end', (statusCode, data) => {\n   *    console.log('\\n'.repeat(5))\n   *    // data length should be 0, as it was sent using the response stream\n   *    console.log(\n   *      `curl - end - status: ${statusCode} - data length: ${data.length}`,\n   *    )\n   *    curl.close()\n   *  })\n   *  curl.on('error', (error, errorCode) => {\n   *    console.log('\\n'.repeat(5))\n   *    console.error('curl - error: ', error, errorCode)\n   *    curl.close()\n   *  })\n   *  curl.perform()\n   * ```\n   *\n   * Multiple calls with the same stream that was previously set has no effect.\n   *\n   * Setting this to `null` will remove the `READFUNCTION` callback and disable this behavior.\n   *\n   * @remarks\n   *\n   * This option is reset after each request, so if you want to upload the same data again using the same\n   * `Curl` instance, you will need to provide a new stream.\n   *\n   * Make sure your libcurl version is greater than or equal 7.69.1.\n   * Versions older than that one are not reliable for streams usage.\n   */\n  setUploadStream(stream: Readable | null) {\n    if (!stream) {\n      if (this.readFunctionStream) {\n        this.cleanupReadFunctionStreamEvents()\n        this.readFunctionStream = null\n        this.setOpt('READFUNCTION', null)\n      }\n      return this\n    }\n\n    if (this.readFunctionStream === stream) return this\n\n    if (\n      typeof stream?.on !== 'function' ||\n      typeof stream?.read !== 'function'\n    ) {\n      throw new Error(\n        'The passed value to setUploadStream does not looks like a stream object',\n      )\n    }\n\n    this.readFunctionStream = stream\n\n    const resumeIfPaused = () => {\n      if (this.streamReadFunctionPaused) {\n        this.streamReadFunctionPaused = false\n\n        // let's unpause only on the next event loop iteration\n        // this will avoid scenarios where the readable event was emitted\n        // between libcurl pausing the transfer from the READFUNCTION\n        // and the next real iteration.\n        setImmediate(() => {\n          // just to make sure we do not try to unpause\n          // a connection that has already finished\n          // this can happen if some error has been throw\n          // in the meantime\n          if (this.isRunning) {\n            this.pause(CurlPause.Cont)\n          }\n        })\n      }\n    }\n\n    const attachEventListenerToStream = (\n      event: string,\n      cb: (...args: any[]) => void,\n    ) => {\n      this.readFunctionStream!.on(event, cb)\n      this.streamReadFunctionCallbacksToClean.push([\n        this.readFunctionStream!,\n        event,\n        cb,\n      ])\n    }\n\n    // TODO: Handle adding the event multiple times?\n    // can only happen if the user calls the method with the same stream more than one time\n    // and due to the if at the top, this is only possible if they use another stream in-between.\n\n    attachEventListenerToStream('readable', () => {\n      resumeIfPaused()\n    })\n\n    // This needs the same logic than the destroy callback for the response stream\n    // inside the default WRITEFUNCTION.\n    // Which basically means we cannot throw an error inside the READFUNCTION itself\n    // as this would cause the pause itself to throw an error\n    // (pause calls the READFUNCTION before returning)\n    // So we must create a fake \"pause\" just to trigger the progress function, and\n    // then the error will be thrown.\n    // This is why the following two callbacks are setting\n    // this.streamReadFunctionShouldPause = true\n    attachEventListenerToStream('close', () => {\n      // If the stream was closed, but end was not called\n      // it means the stream was forcefully destroyed, so\n      // we must let libcurl fail!\n      // streamError could already be set if destroy was called with an error\n      // as it would call the error callback below, so we don't need to do anything.\n      if (!this.streamReadFunctionShouldEnd && !this.streamError) {\n        this.streamError = new Error(\n          'Curl upload stream was unexpectedly destroyed',\n        )\n\n        this.streamReadFunctionShouldPause = true\n        resumeIfPaused()\n      }\n    })\n    attachEventListenerToStream('error', (error: Error) => {\n      this.streamError = error\n\n      this.streamReadFunctionShouldPause = true\n      resumeIfPaused()\n    })\n\n    attachEventListenerToStream('end', () => {\n      this.streamReadFunctionShouldEnd = true\n\n      resumeIfPaused()\n    })\n\n    this.setOpt('READFUNCTION', (buffer, size, nmemb) => {\n      // Remember, we cannot throw this.streamError here.\n\n      if (this.streamReadFunctionShouldPause) {\n        this.streamReadFunctionShouldPause = false\n        this.streamReadFunctionPaused = true\n        return CurlReadFunc.Pause\n      }\n\n      const amountToRead = size * nmemb\n\n      const data = stream.read(amountToRead)\n\n      if (!data) {\n        if (this.streamReadFunctionShouldEnd) {\n          return 0\n        } else {\n          this.streamReadFunctionPaused = true\n          return CurlReadFunc.Pause\n        }\n      }\n\n      const totalWritten = data.copy(buffer)\n\n      // we could also return CurlReadFunc.Abort or CurlReadFunc.Pause here.\n      return totalWritten\n    })\n\n    return this\n  }\n\n  /**\n   * Set the param to `null` to use the Node.js default value.\n   *\n   * @param highWaterMark This will passed directly to the `Readable` stream created to be returned as the response'\n   *\n   * @remarks\n   * Only useful when the {@link CurlFeature.StreamResponse | `StreamResponse`} feature flag is enabled.\n   */\n  setStreamResponseHighWaterMark(highWaterMark: number | null) {\n    this.streamWriteFunctionHighWaterMark = highWaterMark || undefined\n    return this\n  }\n\n  /**\n   * This sets the callback to be used as the progress function when using any of the stream features.\n   *\n   * This is needed because when this `Curl` instance is enabled to use streams for upload/download, it needs\n   * to set the libcurl progress function option to an internal function.\n   *\n   * If you are using any of the streams features, do not overwrite the progress callback to something else,\n   * be it using {@link setOpt | `setOpt`} or {@link setProgressCallback | `setProgressCallback`}, as this would\n   * cause undefined behavior.\n   *\n   * If are using this callback, there is no need to set the `NOPROGRESS` option to false (as you normally would).\n   */\n  setStreamProgressCallback(cb: CurlOptionValueType['xferInfoFunction']) {\n    this.streamUserSuppliedProgressFunction = cb\n\n    return this\n  }\n\n  /**\n   * The option `XFERINFOFUNCTION` was introduced in curl version `7.32.0`,\n   *  versions older than that should use `PROGRESSFUNCTION`.\n   * If you don't want to mess with version numbers you can use this method,\n   * instead of directly calling {@link Curl.setOpt | `Curl#setOpt`}.\n   *\n   * `NOPROGRESS` should be set to false to make this function actually get called.\n   */\n  setProgressCallback(\n    cb:\n      | ((\n          dltotal: number,\n          dlnow: number,\n          ultotal: number,\n          ulnow: number,\n        ) => number)\n      | null,\n  ) {\n    if (Curl.VERSION_NUM >= 0x072000) {\n      this.handle.setOpt(Curl.option.XFERINFOFUNCTION, cb)\n    } else {\n      this.handle.setOpt(Curl.option.PROGRESSFUNCTION, cb)\n    }\n\n    return this\n  }\n\n  /**\n   * Add this instance to the processing queue.\n   * This method should be called only one time per request,\n   *  otherwise it will throw an error.\n   *\n   * @remarks\n   *\n   * This basically calls the {@link \"Multi\".Multi.addHandle | `Multi#addHandle`} method.\n   */\n  perform() {\n    if (this.isRunning) {\n      throw new Error('Handle already running!')\n    }\n\n    this.isRunning = true\n\n    // set progress function to our internal one if using stream upload/download\n    const isStreamEnabled =\n      this.features & CurlFeature.StreamResponse || this.readFunctionStream\n    if (isStreamEnabled) {\n      this.setProgressCallback(this.streamModeProgressFunction.bind(this))\n      this.setOpt('NOPROGRESS', false)\n    }\n\n    multiHandle.addHandle(this.handle)\n\n    return this\n  }\n\n  /**\n   * Perform any connection upkeep checks.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_upkeep()`](http://curl.haxx.se/libcurl/c/curl_easy_upkeep.html)\n   */\n  upkeep() {\n    const code = this.handle.upkeep()\n\n    if (code !== CurlCode.CURLE_OK) {\n      throw new Error(Easy.strError(code))\n    }\n\n    return this\n  }\n\n  /**\n   * Use this function to pause / unpause a connection.\n   *\n   * The bitmask argument is a set of bits that sets the new state of the connection.\n   *\n   * Use {@link CurlPause | `CurlPause`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_pause()`](http://curl.haxx.se/libcurl/c/curl_easy_pause.html)\n   */\n  pause(bitmask: CurlPause) {\n    const code = this.handle.pause(bitmask)\n\n    if (code !== CurlCode.CURLE_OK) {\n      throw new Error(Easy.strError(code))\n    }\n\n    return this\n  }\n\n  /**\n   * Reset this handle options to their defaults.\n   *\n   * This will put the handle in a clean state, as if it was just created.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_reset()`](http://curl.haxx.se/libcurl/c/curl_easy_reset.html)\n   */\n  reset() {\n    this.removeAllListeners()\n    this.handle.reset()\n\n    // add callbacks back as reset will remove them\n    this.handle.setOpt(\n      Curl.option.WRITEFUNCTION,\n      this.defaultWriteFunction.bind(this),\n    )\n    this.handle.setOpt(\n      Curl.option.HEADERFUNCTION,\n      this.defaultHeaderFunction.bind(this),\n    )\n\n    return this\n  }\n\n  /**\n   * Duplicate this handle with all their options.\n   * Keep in mind that, by default, this also means all event listeners.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_duphandle()`](http://curl.haxx.se/libcurl/c/curl_easy_duphandle.html)\n   *\n   * @param shouldCopyEventListeners If you don't want to copy the event listeners, set this to `false`.\n   */\n  dupHandle(shouldCopyEventListeners = true) {\n    const duplicatedHandle = new Curl(this.handle.dupHandle())\n    const eventsToCopy = ['end', 'error', 'data', 'header']\n\n    duplicatedHandle.features = this.features\n\n    if (shouldCopyEventListeners) {\n      for (let i = 0; i < eventsToCopy.length; i += 1) {\n        const listeners = this.listeners(eventsToCopy[i])\n\n        for (let j = 0; j < listeners.length; j += 1) {\n          duplicatedHandle.on(eventsToCopy[i], listeners[j])\n        }\n      }\n    }\n\n    return duplicatedHandle\n  }\n\n  /**\n   * Close this handle.\n   *\n   * **NOTE:** After closing the handle, it must not be used anymore. Doing so will throw an error.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_cleanup()`](http://curl.haxx.se/libcurl/c/curl_easy_cleanup.html)\n   */\n  close() {\n    // TODO(jonathan): on next semver major check if this.handle.isOpen is false and if it is, return immediately.\n    curlInstanceMap.delete(this.handle)\n\n    this.removeAllListeners()\n\n    if (this.handle.isInsideMultiHandle) {\n      multiHandle.removeHandle(this.handle)\n    }\n\n    this.handle.setOpt(Curl.option.WRITEFUNCTION, null)\n    this.handle.setOpt(Curl.option.HEADERFUNCTION, null)\n\n    this.handle.close()\n  }\n\n  /**\n   * This is used to reset a few properties to their pre-request state.\n   */\n  protected resetInternalState() {\n    this.isRunning = false\n\n    this.chunks = []\n    this.chunksLength = 0\n    this.headerChunks = []\n    this.headerChunksLength = 0\n\n    const wasStreamEnabled = this.writeFunctionStream || this.readFunctionStream\n\n    if (wasStreamEnabled) {\n      this.setProgressCallback(null)\n    }\n\n    // reset back the READFUNCTION if there was a stream we were reading from\n    if (this.readFunctionStream) {\n      this.setOpt('READFUNCTION', null)\n    }\n\n    // these are mostly streams related, as these options are not persisted between requests\n    // the streams themselves\n    this.writeFunctionStream = null\n    this.readFunctionStream = null\n    // READFUNCTION / upload related\n    this.streamReadFunctionShouldEnd = false\n    this.streamReadFunctionShouldPause = false\n    this.streamReadFunctionPaused = false\n    // WRITEFUNCTION / download related\n    this.streamWriteFunctionShouldPause = false\n    this.streamWriteFunctionPaused = false\n    this.streamWriteFunctionFirstRun = true\n    // common\n    this.streamPauseNext = false\n    this.streamContinueNext = false\n    this.streamError = false\n    this.streamUserSuppliedProgressFunction = null\n\n    this.cleanupReadFunctionStreamEvents()\n  }\n\n  /**\n   * When uploading a stream (by calling {@link setUploadStream | `setUploadStream`})\n   * some event listeners are attached to the stream instance.\n   * This will remove them so our callbacks are not called anymore.\n   */\n  protected cleanupReadFunctionStreamEvents() {\n    this.streamReadFunctionCallbacksToClean.forEach(([stream, event, cb]) => {\n      stream.off(event, cb)\n    })\n    this.streamReadFunctionCallbacksToClean = []\n  }\n\n  /**\n   * Returns headers from the current stored chunks - if any\n   */\n  protected getHeaders() {\n    const isHeaderStorageEnabled = !(\n      this.features & CurlFeature.NoHeaderStorage\n    )\n    const isHeaderParsingEnabled =\n      !(this.features & CurlFeature.NoHeaderParsing) && isHeaderStorageEnabled\n\n    const headersRaw = isHeaderStorageEnabled\n      ? mergeChunks(this.headerChunks, this.headerChunksLength)\n      : Buffer.alloc(0)\n\n    return isHeaderParsingEnabled\n      ? parseHeaders(decoder.write(headersRaw))\n      : headersRaw\n  }\n\n  /**\n   * The internal function passed to `PROGRESSFUNCTION` (`XFERINFOFUNCTION` on most recent libcurl versions)\n   * when using any of the stream features.\n   */\n  protected streamModeProgressFunction(\n    dltotal: number,\n    dlnow: number,\n    ultotal: number,\n    ulnow: number,\n  ) {\n    if (this.streamError) throw this.streamError\n\n    const ret = this.streamUserSuppliedProgressFunction\n      ? this.streamUserSuppliedProgressFunction.call(\n          this.handle,\n          dltotal,\n          dlnow,\n          ultotal,\n          ulnow,\n        )\n      : 0\n\n    return ret\n  }\n\n  /**\n   * This is the default callback passed to {@link setOpt | `setOpt('WRITEFUNCTION', cb)`}.\n   */\n  protected defaultWriteFunction(chunk: Buffer, size: number, nmemb: number) {\n    // this is a stream based request, so we need a totally different handling\n    if (this.features & CurlFeature.StreamResponse) {\n      return this.defaultWriteFunctionStreamBased(chunk, size, nmemb)\n    }\n\n    if (!(this.features & CurlFeature.NoDataStorage)) {\n      this.chunks.push(chunk)\n      this.chunksLength += chunk.length\n    }\n\n    this.emit('data', chunk, this)\n\n    return size * nmemb\n  }\n\n  /**\n   * This is used by the default callback passed to {@link setOpt | `setOpt('WRITEFUNCTION', cb)`}\n   * when the feature to stream response is enabled.\n   */\n  protected defaultWriteFunctionStreamBased(\n    chunk: Buffer,\n    size: number,\n    nmemb: number,\n  ) {\n    if (!this.writeFunctionStream) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const handle = this\n      // create the response stream we are going to use\n      this.writeFunctionStream = new Readable({\n        highWaterMark: this.streamWriteFunctionHighWaterMark,\n        destroy(error, cb) {\n          handle.streamError =\n            error ||\n            new Error('Curl response stream was unexpectedly destroyed')\n\n          // let the event loop run one more time before we do anything\n          // if the handle is not running anymore it means that the\n          // error we set above was caught, if it is still running, then it means that:\n          // - the handle is paused\n          // - the progress function was not called yet\n          // If this is the case, then we just unpause the handle. This will cause the following:\n          // - the WRITEFUNCTION callback will be called\n          // - this will pause the handle again (because we cannot throw the error in here)\n          // - the PROGRESSFUNCTION callback will be called, and then the error will be thrown.\n          setImmediate(() => {\n            if (handle.isRunning && handle.streamWriteFunctionPaused) {\n              handle.streamWriteFunctionPaused = false\n              handle.streamWriteFunctionShouldPause = true\n              try {\n                handle.pause(CurlPause.RecvCont)\n              } catch (error) {\n                cb(error)\n                return\n              }\n            }\n\n            cb(null)\n          })\n        },\n        read(_size) {\n          if (\n            handle.streamWriteFunctionFirstRun ||\n            handle.streamWriteFunctionPaused\n          ) {\n            if (handle.streamWriteFunctionFirstRun) {\n              handle.streamWriteFunctionFirstRun = false\n            }\n            // we must allow Node.js to process the whole event queue\n            // before we unpause\n            setImmediate(() => {\n              if (handle.isRunning) {\n                handle.streamWriteFunctionPaused = false\n                handle.pause(CurlPause.RecvCont)\n              }\n            })\n          }\n        },\n      })\n\n      // as soon as we have the stream, we need to emit the \"stream\" event\n      // but the \"stream\" event needs the statusCode and the headers, so this\n      // is what we are retrieving here.\n      const headers = this.getHeaders()\n\n      const { code, data: status } = this.handle.getInfo(\n        Curl.info.RESPONSE_CODE,\n      )\n\n      if (code !== CurlCode.CURLE_OK) {\n        const error = new Error('Could not get status code of request')\n        this.emit('error', error, code, this)\n        return 0\n      }\n\n      // let's emit the event only in the next iteration of the event loop\n      // We need to do this otherwise the event listener callbacks would run\n      // before the pause below, and this is probably not what we want.\n      setImmediate(() =>\n        this.emit('stream', this.writeFunctionStream, status, headers, this),\n      )\n\n      this.streamWriteFunctionPaused = true\n      return CurlWriteFunc.Pause\n    }\n\n    // pause this req\n    if (this.streamWriteFunctionShouldPause) {\n      this.streamWriteFunctionShouldPause = false\n      this.streamWriteFunctionPaused = true\n      return CurlWriteFunc.Pause\n    }\n\n    // write to the stream\n    const ok = this.writeFunctionStream.push(chunk)\n\n    // pause connection until there is more data\n    if (!ok) {\n      this.streamWriteFunctionPaused = true\n      this.pause(CurlPause.Recv)\n    }\n\n    return size * nmemb\n  }\n\n  /**\n   * This is the default callback passed to {@link setOpt | `setOpt('HEADERFUNCTION', cb)`}.\n   */\n  protected defaultHeaderFunction(chunk: Buffer, size: number, nmemb: number) {\n    if (!(this.features & CurlFeature.NoHeaderStorage)) {\n      this.headerChunks.push(chunk)\n      this.headerChunksLength += chunk.length\n    }\n\n    this.emit('header', chunk, this)\n\n    return size * nmemb\n  }\n\n  /**\n   * Returns an object with a representation of the current libcurl version and their features/protocols.\n   *\n   * This is basically [`curl_version_info()`](https://curl.haxx.se/libcurl/c/curl_version_info.html)\n   */\n  static getVersionInfo = () => CurlVersionInfo\n\n  /**\n   * Returns a string that looks like the one returned by\n   * ```bash\n   * curl -V\n   * ```\n   * Example:\n   * ```\n   * Version: libcurl/7.69.1-DEV OpenSSL/1.1.1d zlib/1.2.11 WinIDN libssh2/1.9.0_DEV nghttp2/1.40.0\n   * Protocols: dict, file, ftp, ftps, gopher, http, https, imap, imaps, ldap, ldaps, pop3, pop3s, rtsp, scp, sftp, smb, smbs, smtp, smtps, telnet, tftp\n   * Features: AsynchDNS, IDN, IPv6, Largefile, SSPI, Kerberos, SPNEGO, NTLM, SSL, libz, HTTP2, HTTPS-proxy\n   * ```\n   */\n  static getVersionInfoString = () => {\n    const version = Curl.getVersion()\n    const protocols = CurlVersionInfo.protocols.join(', ')\n    const features = CurlVersionInfo.features.join(', ')\n\n    return [\n      `Version: ${version}`,\n      `Protocols: ${protocols}`,\n      `Features: ${features}`,\n    ].join('\\n')\n  }\n\n  /**\n   * Useful if you want to check if the current libcurl version is greater or equal than another one.\n   * @param x major\n   * @param y minor\n   * @param z patch\n   */\n  static isVersionGreaterOrEqualThan = (x: number, y: number, z = 0) => {\n    return _Curl.VERSION_NUM >= (x << 16) + (y << 8) + z\n  }\n}\n\ninterface Curl {\n  on(\n    event: 'data',\n    listener: (this: Curl, chunk: Buffer, curlInstance: Curl) => void,\n  ): this\n  on(\n    event: 'header',\n    listener: (this: Curl, chunk: Buffer, curlInstance: Curl) => void,\n  ): this\n  on(\n    event: 'error',\n    listener: (\n      this: Curl,\n      error: Error,\n      errorCode: CurlCode,\n      curlInstance: Curl,\n    ) => void,\n  ): this\n  /**\n   * This is emitted if the StreamResponse feature was enabled.\n   */\n  on(\n    event: 'stream',\n    listener: (\n      this: Curl,\n      stream: Readable,\n      status: number,\n      headers: Buffer | HeaderInfo[],\n      curlInstance: Curl,\n    ) => void,\n  ): this\n  /**\n   * The `data` paramater passed to the listener callback will be one of the following:\n   *  - Empty `Buffer` if the feature {@link CurlFeature.NoDataStorage | `NoDataStorage`} flag was enabled\n   *  - Non-Empty `Buffer` if the feature {@link CurlFeature.NoDataParsing | `NoDataParsing`} flag was enabled\n   *  - Otherwise, it will be a string, with the result of decoding the received data as a UTF8 string.\n   *      If it's a JSON string for example, you still need to call JSON.parse on it. This library does no extra parsing\n   *       whatsoever.\n   *\n   * The `headers` parameter passed to the listener callback will be one of the following:\n   *  - Empty `Buffer` if the feature {@link CurlFeature.NoHeaderParsing | `NoHeaderStorage`} flag was enabled\n   *  - Non-Empty `Buffer` if the feature {@link CurlFeature.NoHeaderParsing | `NoHeaderParsing`} flag was enabled\n   *  - Otherwise, an array of parsed headers for each request\n   *     libcurl made (if there were 2 redirects before the last request, the array will have 3 elements, one for each request)\n   */\n  on(\n    event: 'end',\n    listener: (\n      this: Curl,\n      status: number,\n      data: string | Buffer,\n      headers: Buffer | HeaderInfo[],\n      curlInstance: Curl,\n    ) => void,\n  ): this\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  on(event: string, listener: Function): this\n\n  // START AUTOMATICALLY GENERATED CODE - DO NOT EDIT\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: DataCallbackOptions,\n    value:\n      | ((\n          this: EasyNativeBinding,\n          data: Buffer,\n          size: number,\n          nmemb: number,\n        ) => number)\n      | null,\n  ): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: ProgressCallbackOptions,\n    value:\n      | ((\n          this: EasyNativeBinding,\n          dltotal: number,\n          dlnow: number,\n          ultotal: number,\n          ulnow: number,\n        ) => number | CurlProgressFunc)\n      | null,\n  ): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: StringListOptions, value: string[] | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: BlobOptions, value: ArrayBuffer | Buffer | string | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: 'CHUNK_BGN_FUNCTION',\n    value:\n      | ((\n          this: EasyNativeBinding,\n          fileInfo: FileInfo,\n          remains: number,\n        ) => CurlChunk)\n      | null,\n  ): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: 'CHUNK_END_FUNCTION',\n    value: ((this: EasyNativeBinding) => CurlChunk) | null,\n  ): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: 'DEBUGFUNCTION',\n    value:\n      | ((this: EasyNativeBinding, type: CurlInfoDebug, data: Buffer) => 0)\n      | null,\n  ): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: 'FNMATCH_FUNCTION',\n    value:\n      | ((\n          this: EasyNativeBinding,\n          pattern: string,\n          value: string,\n        ) => CurlFnMatchFunc)\n      | null,\n  ): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   * You can either return a single `CurlHstsReadCallbackResult` object or an array of `CurlHstsReadCallbackResult` objects.\n   * If returning an array, the callback will only be called once per request.\n   * If returning a single object, the callback will be called multiple times until `null` is returned.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: 'HSTSREADFUNCTION',\n    value:\n      | ((\n          this: EasyNativeBinding,\n        ) => null | CurlHstsCacheEntry | CurlHstsCacheEntry[])\n      | null,\n  ): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: 'HSTSWRITEFUNCTION',\n    value:\n      | ((\n          this: EasyNativeBinding,\n          cacheEntry: CurlHstsCacheEntry,\n          cacheCount: CurlHstsCacheCount,\n        ) => any)\n      | null,\n  ): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: 'SEEKFUNCTION',\n    value:\n      | ((this: EasyNativeBinding, offset: number, origin: number) => number)\n      | null,\n  ): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: 'TRAILERFUNCTION',\n    value: ((this: EasyNativeBinding) => string[] | false) | null,\n  ): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'SHARE', value: Share | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'HTTPPOST', value: HttpPostField[] | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'FTP_SSL_CCC', value: CurlFtpSsl | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'FTP_FILEMETHOD', value: CurlFtpMethod | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'GSSAPI_DELEGATION', value: CurlGssApi | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'HEADEROPT', value: CurlHeader | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'HTTP_VERSION', value: CurlHttpVersion | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'IPRESOLVE', value: CurlIpResolve | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'NETRC', value: CurlNetrc | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'PROTOCOLS', value: CurlProtocol | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'PROXY_SSL_OPTIONS', value: CurlSslOpt | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'PROXYTYPE', value: CurlProxy | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'REDIR_PROTOCOLS', value: CurlProtocol | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'RTSP_REQUEST', value: CurlRtspRequest | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'SSH_AUTH_TYPES', value: CurlSshAuth | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'SSL_OPTIONS', value: CurlSslOpt | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'SSLVERSION', value: CurlSslVersion | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'TIMECONDITION', value: CurlTimeCond | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'USE_SSL', value: CurlUseSsl | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(option: 'HSTS_CTRL', value: CurlHsts | null): this\n  /**\n   * Use {@link \"Curl\".Curl.option|`Curl.option`} for predefined constants.\n   *\n   *\n   * Official libcurl documentation: [`curl_easy_setopt()`](http://curl.haxx.se/libcurl/c/curl_easy_setopt.html)\n   */\n  setOpt(\n    option: Exclude<CurlOptionName, SpecificOptions>,\n    value: string | number | boolean | null,\n  ): this\n  // END AUTOMATICALLY GENERATED CODE - DO NOT EDIT\n\n  // overloaded getInfo definitions - changes made here must also be made in EasyNativeBinding.ts\n  // TODO: do this automatically, like above.\n\n  /**\n   * Returns information about the finished connection.\n   *\n   * Official libcurl documentation: [`curl_easy_getinfo()`](http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html)\n   *\n   * @param info Info to retrieve. Use {@link \"Curl\".Curl.info | `Curl.info`} for predefined constants.\n   */\n  getInfo(info: 'CERTINFO'): GetInfoReturn<string[]>['data']\n\n  /**\n   * Returns information about the finished connection.\n   *\n   * Official libcurl documentation: [`curl_easy_getinfo()`](http://curl.haxx.se/libcurl/c/curl_easy_getinfo.html)\n   *\n   * @param info Info to retrieve. Use {@link \"Curl\".Curl.info | `Curl.info`} for predefined constants.\n   */\n  getInfo(\n    info: Exclude<CurlInfoName, CurlInfoNameSpecific>,\n  ): GetInfoReturn['data']\n}\n\nexport { Curl }\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}