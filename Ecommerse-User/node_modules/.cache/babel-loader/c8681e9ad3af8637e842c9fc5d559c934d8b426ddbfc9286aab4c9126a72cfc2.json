{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.curly = void 0;\nconst CurlOption_1 = require(\"./generated/CurlOption\");\nconst Curl_1 = require(\"./Curl\");\nconst CurlFeature_1 = require(\"./enum/CurlFeature\");\n// This is basically http.METHODS\nconst methods = ['acl', 'bind', 'checkout', 'connect', 'copy', 'delete', 'get', 'head', 'link', 'lock', 'm-search', 'merge', 'mkactivity', 'mkcalendar', 'mkcol', 'move', 'notify', 'options', 'patch', 'post', 'propfind', 'proppatch', 'purge', 'put', 'rebind', 'report', 'search', 'source', 'subscribe', 'trace', 'unbind', 'unlink', 'unlock', 'unsubscribe'];\nconst create = function () {\n  let defaultOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  function curly(url) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const curlHandle = new Curl_1.Curl();\n    curlHandle.enable(CurlFeature_1.CurlFeature.NoDataParsing);\n    curlHandle.setOpt('URL', `${options.curlyBaseUrl || ''}${url}`);\n    const finalOptions = {\n      ...defaultOptions,\n      ...options\n    };\n    for (const key of Object.keys(finalOptions)) {\n      const keyTyped = key;\n      const optionName = keyTyped in CurlOption_1.CurlOptionCamelCaseMap ? CurlOption_1.CurlOptionCamelCaseMap[keyTyped] : keyTyped;\n      // if it begins with curly we do not set it on the curlHandle\n      // as it's an specific option for curly\n      if (optionName.startsWith('curly')) continue;\n      // @ts-ignore @TODO Try to type this\n      curlHandle.setOpt(optionName, finalOptions[key]);\n    }\n    // streams!\n    const {\n      curlyStreamResponse,\n      curlyStreamResponseHighWaterMark,\n      curlyStreamUpload\n    } = finalOptions;\n    const isUsingStream = !!(curlyStreamResponse || curlyStreamUpload);\n    if (finalOptions.curlyProgressCallback) {\n      if (typeof finalOptions.curlyProgressCallback !== 'function') {\n        throw new TypeError('curlyProgressCallback must be a function with signature (number, number, number, number) => number');\n      }\n      const fnToCall = isUsingStream ? 'setStreamProgressCallback' : 'setProgressCallback';\n      curlHandle[fnToCall](finalOptions.curlyProgressCallback);\n    }\n    if (curlyStreamResponse) {\n      curlHandle.enable(CurlFeature_1.CurlFeature.StreamResponse);\n      if (curlyStreamResponseHighWaterMark) {\n        curlHandle.setStreamResponseHighWaterMark(curlyStreamResponseHighWaterMark);\n      }\n    }\n    if (curlyStreamUpload) {\n      curlHandle.setUploadStream(curlyStreamUpload);\n    }\n    const lowerCaseHeadersIfNecessary = headers => {\n      // in-place modification\n      // yeah, I know mutability is bad and all that\n      if (finalOptions.curlyLowerCaseHeaders) {\n        for (const headersReq of headers) {\n          const entries = Object.entries(headersReq);\n          for (const [headerKey, headerValue] of entries) {\n            delete headersReq[headerKey];\n            headersReq[headerKey.toLowerCase()] = headerValue;\n          }\n        }\n      }\n    };\n    return new Promise((resolve, reject) => {\n      let stream;\n      if (curlyStreamResponse) {\n        curlHandle.on('stream', (_stream, statusCode, headers) => {\n          lowerCaseHeadersIfNecessary(headers);\n          stream = _stream;\n          resolve({\n            // @ts-ignore cannot be subtype yada yada\n            data: stream,\n            statusCode,\n            headers\n          });\n        });\n      }\n      curlHandle.on('end', (statusCode, data, headers) => {\n        curlHandle.close();\n        // only need to the remaining here if we did not enabled\n        // the stream response\n        if (curlyStreamResponse) {\n          return;\n        }\n        const contentTypeEntry = Object.entries(headers[headers.length - 1]).find(_ref => {\n          let [k] = _ref;\n          return k.toLowerCase() === 'content-type';\n        });\n        let contentType = contentTypeEntry ? contentTypeEntry[1] : '';\n        // remove the metadata of the content-type, like charset\n        // See https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n        contentType = contentType.split(';')[0];\n        const responseBodyParsers = {\n          ...curly.defaultResponseBodyParsers,\n          ...finalOptions.curlyResponseBodyParsers\n        };\n        let foundParser = finalOptions.curlyResponseBodyParser;\n        if (typeof foundParser === 'undefined') {\n          for (const [contentTypeFormat, parser] of Object.entries(responseBodyParsers)) {\n            if (typeof parser !== 'function') {\n              return reject(new TypeError(`Response body parser for ${contentTypeFormat} must be a function`));\n            }\n            if (contentType === contentTypeFormat) {\n              foundParser = parser;\n              break;\n            } else if (contentTypeFormat === '*') {\n              foundParser = parser;\n              break;\n            } else {\n              const partsFormat = contentTypeFormat.split('/');\n              const partsContentType = contentType.split('/');\n              if (partsContentType.length === partsFormat.length && partsContentType.every((val, index) => partsFormat[index] === '*' || partsFormat[index] === val)) {\n                foundParser = parser;\n                break;\n              }\n            }\n          }\n        }\n        if (foundParser && typeof foundParser !== 'function') {\n          return reject(new TypeError('`curlyResponseBodyParser` passed to curly must be false or a function.'));\n        }\n        lowerCaseHeadersIfNecessary(headers);\n        try {\n          resolve({\n            statusCode: statusCode,\n            data: foundParser ? foundParser(data, headers) : data,\n            headers: headers\n          });\n        } catch (error) {\n          reject(error);\n        }\n      });\n      curlHandle.on('error', (error, errorCode) => {\n        curlHandle.close();\n        // @ts-ignore\n        error.code = errorCode;\n        // @ts-ignore\n        error.isCurlError = true;\n        // oops, if have a stream it means the promise\n        // has been resolved with it\n        // so instead of rejecting the original promise\n        // we are emitting the error event on the stream\n        if (stream) {\n          stream.emit('error', error);\n        } else {\n          reject(error);\n        }\n      });\n      try {\n        curlHandle.perform();\n      } catch (error) /* istanbul ignore next: this should never happen 🤷‍♂️ */{\n        curlHandle.close();\n        reject(error);\n      }\n    });\n  }\n  curly.create = create;\n  curly.defaultResponseBodyParsers = {\n    'application/json': (data, _headers) => {\n      try {\n        const string = data.toString('utf8');\n        return JSON.parse(string);\n      } catch (error) {\n        throw new Error(`curly failed to parse \"application/json\" content as JSON. This is generally caused by receiving malformed JSON data from the server.\nYou can disable this automatic behavior by setting the option curlyResponseBodyParser to false, then a Buffer will be returned as the data.\nYou can also overwrite the \"application/json\" parser with your own by changing one of the following:\n  - curly.defaultResponseBodyParsers['application/json']\n  or\n  - options.curlyResponseBodyParsers = { 'application/json': parser }\n\nIf you want just a single function to handle all content-types, you can use the option \"curlyResponseBodyParser\".\n`);\n      }\n    },\n    // We are in [INSERT CURRENT YEAR], let's assume everyone is using utf8 encoding for text/* content-type.\n    'text/*': (data, _headers) => data.toString('utf8'),\n    // otherwise let's just return the raw buffer\n    '*': (data, _headers) => data\n  };\n  const httpMethodOptionsMap = {\n    get: null,\n    post: (_m, o) => ({\n      post: true,\n      ...o\n    }),\n    head: (_m, o) => ({\n      nobody: true,\n      ...o\n    }),\n    _: (m, o) => ({\n      customRequest: m.toUpperCase(),\n      ...o\n    })\n  };\n  for (const httpMethod of methods) {\n    const httpMethodOptionsKey = Object.prototype.hasOwnProperty.call(httpMethodOptionsMap, httpMethod) ? httpMethod : '_';\n    const httpMethodOptions = httpMethodOptionsMap[httpMethodOptionsKey];\n    // @ts-ignore\n    curly[httpMethod] = httpMethodOptions === null ? curly : function (url) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return curly(url, {\n        ...httpMethodOptions(httpMethod, options)\n      });\n    };\n  }\n  // @ts-ignore\n  return curly;\n};\n/**\r\n * Curly function\r\n *\r\n * @public\r\n */\nexports.curly = create();","map":{"version":3,"names":["CurlOption_1","require","Curl_1","CurlFeature_1","methods","create","defaultOptions","arguments","length","undefined","curly","url","options","curlHandle","Curl","enable","CurlFeature","NoDataParsing","setOpt","curlyBaseUrl","finalOptions","key","Object","keys","keyTyped","optionName","CurlOptionCamelCaseMap","startsWith","curlyStreamResponse","curlyStreamResponseHighWaterMark","curlyStreamUpload","isUsingStream","curlyProgressCallback","TypeError","fnToCall","StreamResponse","setStreamResponseHighWaterMark","setUploadStream","lowerCaseHeadersIfNecessary","headers","curlyLowerCaseHeaders","headersReq","entries","headerKey","headerValue","toLowerCase","Promise","resolve","reject","stream","on","_stream","statusCode","data","close","contentTypeEntry","find","_ref","k","contentType","split","responseBodyParsers","defaultResponseBodyParsers","curlyResponseBodyParsers","foundParser","curlyResponseBodyParser","contentTypeFormat","parser","partsFormat","partsContentType","every","val","index","error","errorCode","code","isCurlError","emit","perform","application/json","_headers","string","toString","JSON","parse","Error","text/*","*","httpMethodOptionsMap","get","post","_m","o","head","nobody","_","m","customRequest","toUpperCase","httpMethod","httpMethodOptionsKey","prototype","hasOwnProperty","call","httpMethodOptions","exports"],"sources":["D:\\Rabbil Laravel\\Ecommerce-Project\\Ecommerse-User\\node_modules\\node-libcurl\\lib\\curly.ts"],"sourcesContent":["/**\n * Copyright (c) Jonathan Cardoso Machado. All Rights Reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nimport { Readable } from 'stream'\n\nimport {\n  CurlOptionName,\n  CurlOptionCamelCaseMap,\n  CurlOptionValueType,\n} from './generated/CurlOption'\n\nimport { HeaderInfo } from './parseHeaders'\n\nimport { Curl } from './Curl'\nimport { CurlFeature } from './enum/CurlFeature'\n\n/**\n * Object the curly call resolves to.\n *\n * @public\n */\nexport interface CurlyResult<ResultData extends any = any> {\n  /**\n   * Data will be the body of the requested URL\n   */\n  data: ResultData\n\n  /**\n   * Parsed headers\n   *\n   * See {@link HeaderInfo}\n   */\n  headers: HeaderInfo[]\n\n  /**\n   * HTTP Status code for the last request\n   */\n  statusCode: number\n}\n\n// This is basically http.METHODS\nconst methods = [\n  'acl',\n  'bind',\n  'checkout',\n  'connect',\n  'copy',\n  'delete',\n  'get',\n  'head',\n  'link',\n  'lock',\n  'm-search',\n  'merge',\n  'mkactivity',\n  'mkcalendar',\n  'mkcol',\n  'move',\n  'notify',\n  'options',\n  'patch',\n  'post',\n  'propfind',\n  'proppatch',\n  'purge',\n  'put',\n  'rebind',\n  'report',\n  'search',\n  'source',\n  'subscribe',\n  'trace',\n  'unbind',\n  'unlink',\n  'unlock',\n  'unsubscribe',\n] as const\n\ntype HttpMethod = typeof methods[number]\n\nexport type CurlyResponseBodyParser = (\n  data: Buffer,\n  header: HeaderInfo[],\n) => any\n\nexport type CurlyResponseBodyParsersProperty = {\n  [key: string]: CurlyResponseBodyParser\n}\n\n/**\n * These are the options accepted by the {@link CurlyFunction | `CurlyFunction`} API.\n *\n * Most libcurl options are accepted as their specific name, like `PROXY_CAPATH`, or as a camel\n * case version of that name, like `proxyCaPath`.\n *\n * Options specific to the `curly` API are prefixed with `curly`, like `curlyBaseUrl`.\n *\n * For quick navigation use the sidebar.\n */\nexport interface CurlyOptions extends CurlOptionValueType {\n  /**\n   * Set this to a callback function that should be used as the progress callback.\n   *\n   * This is the only reliable way to set the progress callback.\n   *\n   * @remarks\n   *\n   * This basically calls one of the following methods, depending on if any of the streams feature is being used or not:\n   * - If using streams: {@link \"Curl\".Curl.setStreamProgressCallback | `Curl#setStreamProgressCallback`}\n   * - else:  {@link \"Curl\".Curl.setProgressCallback | `Curl#setProgressCallback`}\n   */\n  curlyProgressCallback?: CurlOptionValueType['xferInfoFunction']\n\n  /**\n   * If set to a function this will always be called\n   * for all requests, ignoring other response body parsers.\n   *\n   * This can also be set to `false`, which will disable the response parsing and will make\n   * the raw `Buffer` of the response to be returned.\n   */\n  curlyResponseBodyParser?: CurlyResponseBodyParser | false\n\n  /**\n   * Add more response body parsers, or overwrite existing ones.\n   *\n   * This object is merged with the {@link CurlyFunction.defaultResponseBodyParsers | `curly.defaultResponseBodyParsers`}\n   */\n  curlyResponseBodyParsers?: CurlyResponseBodyParsersProperty\n\n  /**\n   * If set, this value will always prefix the `URL` of the request.\n   *\n   * No special handling is done, so make sure you set the url correctly later on.\n   */\n  curlyBaseUrl?: string\n\n  /**\n   * If `true`, `curly` will lower case all headers before returning then.\n   *\n   * By default this is `false`.\n   */\n  curlyLowerCaseHeaders?: boolean\n\n  /**\n   * If `true`, `curly` will return the response data as a stream.\n   *\n   * The `curly` call will resolve as soon as the stream is available.\n   *\n   * When using this option, if an error is thrown in the internal {@link \"Curl\".Curl | `Curl`} instance\n   * after the `curly` call has been resolved (it resolves as soon as the stream is available)\n   * it will cause the `error` event to be emitted on the stream itself, this way it's possible\n   * to handle these too, if necessary. The error object will have the property `isCurlError` set to `true`.\n   *\n   * Calling `destroy()` on the stream will always cause the `Curl` instance to emit the error event.\n   * Even if an error argument was not supplied to `stream.destroy()`.\n   *\n   * By default this is `false`.\n   *\n   * @remarks\n   *\n   * Make sure your libcurl version is greater than or equal 7.69.1.\n   * Versions older than that one are not reliable for streams usage.\n   *\n   * This basically enables the {@link CurlFeature.StreamResponse | `CurlFeature.StreamResponse`} feature\n   * flag in the internal {@link \"Curl\".Curl | `Curl`} instance.\n   */\n  curlyStreamResponse?: boolean\n\n  /**\n   * This will set the `hightWaterMark` option in the response stream, if `curlyStreamResponse` is `true`.\n   *\n   * @remarks\n   *\n   * This basically calls {@link \"Curl\".Curl.setStreamResponseHighWaterMark | `Curl#setStreamResponseHighWaterMark`}\n   * method in the internal {@link \"Curl\".Curl | `Curl`} instance.\n   */\n  curlyStreamResponseHighWaterMark?: number\n\n  /**\n   * If set, the contents of this stream will be uploaded to the server.\n   *\n   * Keep in mind that if you set this option you **SHOULD** not set\n   * `progressFunction` or `xferInfoFunction`, as these are used internally.\n   *\n   * If you need to set a progress callback, use the `curlyProgressCallback` option.\n   *\n   * If the stream set here is destroyed before libcurl finishes uploading it, the error\n   * `Curl upload stream was unexpectedly destroyed` (Code `42`) will be emitted in the\n   * internal {@link \"Curl\".Curl | `Curl`} instance, and so will cause the curly call to be rejected with that error.\n   *\n   * If the stream was destroyed with a specific error, this error will be passed instead.\n   *\n   * By default this is not set.\n   *\n   * @remarks\n   *\n   * Make sure your libcurl version is greater than or equal 7.69.1.\n   * Versions older than that one are not reliable for streams usage.\n   *\n   * This basically calls {@link \"Curl\".Curl.setUploadStream | `Curl#setUploadStream`}\n   * method in the internal {@link \"Curl\".Curl | `Curl`} instance.\n   */\n  curlyStreamUpload?: Readable | null\n}\n\ninterface CurlyHttpMethodCall {\n  /**\n   * **EXPERIMENTAL** This API can change between minor releases\n   *\n   * Async wrapper around the Curl class.\n   *\n   * The `curly.<field>` being used will be the HTTP verb sent.\n   *\n   * @typeParam ResultData You can use this to specify the type of the `data` property returned from this call.\n   */\n  <ResultData extends any = any>(url: string, options?: CurlyOptions): Promise<\n    CurlyResult<ResultData>\n  >\n}\n\n// type HttpMethodCalls = { readonly [K in HttpMethod]: CurlyHttpMethodCall }\ntype HttpMethodCalls = Record<HttpMethod, CurlyHttpMethodCall>\n\nexport interface CurlyFunction extends HttpMethodCalls {\n  /**\n   * **EXPERIMENTAL** This API can change between minor releases\n   *\n   * Async wrapper around the Curl class.\n   *\n   * It's also possible to request using a specific http verb\n   *  directly by using `curl.<http-verb>(url: string, options?: CurlyOptions)`, like:\n   *\n   * ```js\n   * curly.get('https://www.google.com')\n   * ```\n   * @typeParam ResultData You can use this to specify the type of the `data` property returned from this call.\n   */\n  <ResultData extends any = any>(url: string, options?: CurlyOptions): Promise<\n    CurlyResult<ResultData>\n  >\n\n  /**\n   * **EXPERIMENTAL** This API can change between minor releases\n   *\n   * This returns a new `curly` with the specified options set by default.\n   */\n  create: (defaultOptions?: CurlyOptions) => CurlyFunction\n\n  /**\n   * These are the default response body parsers to be used.\n   *\n   * By default there are parsers for the following:\n   *\n   * - application/json\n   * - text/*\n   * - *\n   */\n  defaultResponseBodyParsers: CurlyResponseBodyParsersProperty\n}\n\nconst create = (defaultOptions: CurlyOptions = {}): CurlyFunction => {\n  function curly<ResultData extends any>(\n    url: string,\n    options: CurlyOptions = {},\n  ): Promise<CurlyResult<ResultData>> {\n    const curlHandle = new Curl()\n\n    curlHandle.enable(CurlFeature.NoDataParsing)\n\n    curlHandle.setOpt('URL', `${options.curlyBaseUrl || ''}${url}`)\n\n    const finalOptions = {\n      ...defaultOptions,\n      ...options,\n    }\n\n    for (const key of Object.keys(finalOptions)) {\n      const keyTyped = key as keyof CurlyOptions\n\n      const optionName: CurlOptionName =\n        keyTyped in CurlOptionCamelCaseMap\n          ? CurlOptionCamelCaseMap[\n              keyTyped as keyof typeof CurlOptionCamelCaseMap\n            ]\n          : (keyTyped as CurlOptionName)\n\n      // if it begins with curly we do not set it on the curlHandle\n      // as it's an specific option for curly\n      if (optionName.startsWith('curly')) continue\n\n      // @ts-ignore @TODO Try to type this\n      curlHandle.setOpt(optionName, finalOptions[key])\n    }\n\n    // streams!\n    const {\n      curlyStreamResponse,\n      curlyStreamResponseHighWaterMark,\n      curlyStreamUpload,\n    } = finalOptions\n    const isUsingStream = !!(curlyStreamResponse || curlyStreamUpload)\n\n    if (finalOptions.curlyProgressCallback) {\n      if (typeof finalOptions.curlyProgressCallback !== 'function') {\n        throw new TypeError(\n          'curlyProgressCallback must be a function with signature (number, number, number, number) => number',\n        )\n      }\n\n      const fnToCall = isUsingStream\n        ? 'setStreamProgressCallback'\n        : 'setProgressCallback'\n\n      curlHandle[fnToCall](finalOptions.curlyProgressCallback)\n    }\n\n    if (curlyStreamResponse) {\n      curlHandle.enable(CurlFeature.StreamResponse)\n\n      if (curlyStreamResponseHighWaterMark) {\n        curlHandle.setStreamResponseHighWaterMark(\n          curlyStreamResponseHighWaterMark,\n        )\n      }\n    }\n\n    if (curlyStreamUpload) {\n      curlHandle.setUploadStream(curlyStreamUpload)\n    }\n\n    const lowerCaseHeadersIfNecessary = (headers: HeaderInfo[]) => {\n      // in-place modification\n      // yeah, I know mutability is bad and all that\n      if (finalOptions.curlyLowerCaseHeaders) {\n        for (const headersReq of headers) {\n          const entries = Object.entries(headersReq)\n          for (const [headerKey, headerValue] of entries) {\n            delete headersReq[headerKey]\n            headersReq[headerKey.toLowerCase()] = headerValue\n          }\n        }\n      }\n    }\n\n    return new Promise((resolve, reject) => {\n      let stream: Readable\n\n      if (curlyStreamResponse) {\n        curlHandle.on(\n          'stream',\n          (_stream, statusCode, headers: HeaderInfo[]) => {\n            lowerCaseHeadersIfNecessary(headers)\n\n            stream = _stream\n\n            resolve({\n              // @ts-ignore cannot be subtype yada yada\n              data: stream,\n              statusCode,\n              headers,\n            })\n          },\n        )\n      }\n\n      curlHandle.on(\n        'end',\n        (statusCode, data: Buffer, headers: HeaderInfo[]) => {\n          curlHandle.close()\n\n          // only need to the remaining here if we did not enabled\n          // the stream response\n          if (curlyStreamResponse) {\n            return\n          }\n\n          const contentTypeEntry = Object.entries(\n            headers[headers.length - 1],\n          ).find(([k]) => k.toLowerCase() === 'content-type')\n\n          let contentType = contentTypeEntry ? contentTypeEntry[1] : ''\n\n          // remove the metadata of the content-type, like charset\n          // See https://tools.ietf.org/html/rfc7231#section-3.1.1.5\n          contentType = contentType.split(';')[0]\n\n          const responseBodyParsers = {\n            ...curly.defaultResponseBodyParsers,\n            ...finalOptions.curlyResponseBodyParsers,\n          }\n\n          let foundParser = finalOptions.curlyResponseBodyParser\n\n          if (typeof foundParser === 'undefined') {\n            for (const [contentTypeFormat, parser] of Object.entries(\n              responseBodyParsers,\n            )) {\n              if (typeof parser !== 'function') {\n                return reject(\n                  new TypeError(\n                    `Response body parser for ${contentTypeFormat} must be a function`,\n                  ),\n                )\n              }\n              if (contentType === contentTypeFormat) {\n                foundParser = parser\n                break\n              } else if (contentTypeFormat === '*') {\n                foundParser = parser\n                break\n              } else {\n                const partsFormat = contentTypeFormat.split('/')\n                const partsContentType = contentType.split('/')\n\n                if (\n                  partsContentType.length === partsFormat.length &&\n                  partsContentType.every(\n                    (val, index) =>\n                      partsFormat[index] === '*' || partsFormat[index] === val,\n                  )\n                ) {\n                  foundParser = parser\n                  break\n                }\n              }\n            }\n          }\n\n          if (foundParser && typeof foundParser !== 'function') {\n            return reject(\n              new TypeError(\n                '`curlyResponseBodyParser` passed to curly must be false or a function.',\n              ),\n            )\n          }\n\n          lowerCaseHeadersIfNecessary(headers)\n\n          try {\n            resolve({\n              statusCode: statusCode,\n              data: foundParser ? foundParser(data, headers) : data,\n              headers: headers,\n            })\n          } catch (error) {\n            reject(error)\n          }\n        },\n      )\n\n      curlHandle.on('error', (error, errorCode) => {\n        curlHandle.close()\n\n        // @ts-ignore\n        error.code = errorCode\n        // @ts-ignore\n        error.isCurlError = true\n\n        // oops, if have a stream it means the promise\n        // has been resolved with it\n        // so instead of rejecting the original promise\n        // we are emitting the error event on the stream\n        if (stream) {\n          stream.emit('error', error)\n        } else {\n          reject(error)\n        }\n      })\n\n      try {\n        curlHandle.perform()\n      } catch (error) /* istanbul ignore next: this should never happen 🤷‍♂️ */ {\n        curlHandle.close()\n        reject(error)\n      }\n    })\n  }\n\n  curly.create = create\n\n  curly.defaultResponseBodyParsers = {\n    'application/json': (data, _headers) => {\n      try {\n        const string = data.toString('utf8')\n        return JSON.parse(string)\n      } catch (error) {\n        throw new Error(\n          `curly failed to parse \"application/json\" content as JSON. This is generally caused by receiving malformed JSON data from the server.\nYou can disable this automatic behavior by setting the option curlyResponseBodyParser to false, then a Buffer will be returned as the data.\nYou can also overwrite the \"application/json\" parser with your own by changing one of the following:\n  - curly.defaultResponseBodyParsers['application/json']\n  or\n  - options.curlyResponseBodyParsers = { 'application/json': parser }\n\nIf you want just a single function to handle all content-types, you can use the option \"curlyResponseBodyParser\".\n`,\n        )\n      }\n    },\n    // We are in [INSERT CURRENT YEAR], let's assume everyone is using utf8 encoding for text/* content-type.\n    'text/*': (data, _headers) => data.toString('utf8'),\n    // otherwise let's just return the raw buffer\n    '*': (data, _headers) => data,\n  } as CurlyResponseBodyParsersProperty\n\n  const httpMethodOptionsMap: Record<\n    string,\n    null | ((m: string, o: CurlyOptions) => CurlyOptions)\n  > = {\n    get: null,\n    post: (_m, o) => ({\n      post: true,\n      ...o,\n    }),\n    head: (_m, o) => ({\n      nobody: true,\n      ...o,\n    }),\n    _: (m, o) => ({\n      customRequest: m.toUpperCase(),\n      ...o,\n    }),\n  }\n\n  for (const httpMethod of methods) {\n    const httpMethodOptionsKey = Object.prototype.hasOwnProperty.call(\n      httpMethodOptionsMap,\n      httpMethod,\n    )\n      ? httpMethod\n      : '_'\n    const httpMethodOptions = httpMethodOptionsMap[httpMethodOptionsKey]\n\n    // @ts-ignore\n    curly[httpMethod] =\n      httpMethodOptions === null\n        ? curly\n        : (url: string, options: CurlyOptions = {}) =>\n            curly(url, {\n              ...httpMethodOptions(httpMethod, options),\n            })\n  }\n\n  // @ts-ignore\n  return curly\n}\n\n/**\n * Curly function\n *\n * @public\n */\nexport const curly = create()\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}